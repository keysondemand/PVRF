// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: consensus.proto

#include "consensus.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace fetch {
namespace consensus {
namespace pb {
PROTOBUF_CONSTEXPR Neighbour::Neighbour(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dh_public_key_)*/{}
  , /*decltype(_impl_.key_signature_)*/{}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.public_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0u} {}
struct NeighbourDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NeighbourDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NeighbourDefaultTypeInternal() {}
  union {
    Neighbour _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NeighbourDefaultTypeInternal _Neighbour_default_instance_;
PROTOBUF_CONSTEXPR PrivateShares::PrivateShares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.second_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PrivateSharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrivateSharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrivateSharesDefaultTypeInternal() {}
  union {
    PrivateShares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivateSharesDefaultTypeInternal _PrivateShares_default_instance_;
PROTOBUF_CONSTEXPR Message_Join::Message_Join(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Message_JoinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Message_JoinDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Message_JoinDefaultTypeInternal() {}
  union {
    Message_Join _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Message_JoinDefaultTypeInternal _Message_Join_default_instance_;
PROTOBUF_CONSTEXPR Message_Gossip::Message_Gossip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signature_)*/{}
  , /*decltype(_impl_.msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.origin_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.step_)*/uint64_t{0u}
  , /*decltype(_impl_.gossip_)*/false} {}
struct Message_GossipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Message_GossipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Message_GossipDefaultTypeInternal() {}
  union {
    Message_Gossip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Message_GossipDefaultTypeInternal _Message_Gossip_default_instance_;
PROTOBUF_CONSTEXPR Message::Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageDefaultTypeInternal() {}
  union {
    Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageDefaultTypeInternal _Message_default_instance_;
PROTOBUF_CONSTEXPR Gossip_SignatureShare::Gossip_SignatureShare(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.share_sig_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.share_pi_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.share_pi2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct Gossip_SignatureShareDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Gossip_SignatureShareDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Gossip_SignatureShareDefaultTypeInternal() {}
  union {
    Gossip_SignatureShare _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Gossip_SignatureShareDefaultTypeInternal _Gossip_SignatureShare_default_instance_;
PROTOBUF_CONSTEXPR Gossip::Gossip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct GossipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GossipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GossipDefaultTypeInternal() {}
  union {
    Gossip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GossipDefaultTypeInternal _Gossip_default_instance_;
PROTOBUF_CONSTEXPR Direct_RBC_Tag::Direct_RBC_Tag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.channel_id_)*/0u
  , /*decltype(_impl_.rank_)*/0u
  , /*decltype(_impl_.seq_)*/0u} {}
struct Direct_RBC_TagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Direct_RBC_TagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Direct_RBC_TagDefaultTypeInternal() {}
  union {
    Direct_RBC_Tag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Direct_RBC_TagDefaultTypeInternal _Direct_RBC_Tag_default_instance_;
PROTOBUF_CONSTEXPR Direct_RBC_Message::Direct_RBC_Message(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct Direct_RBC_MessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Direct_RBC_MessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Direct_RBC_MessageDefaultTypeInternal() {}
  union {
    Direct_RBC_Message _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Direct_RBC_MessageDefaultTypeInternal _Direct_RBC_Message_default_instance_;
PROTOBUF_CONSTEXPR Direct_RBC_Hash::Direct_RBC_Hash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct Direct_RBC_HashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Direct_RBC_HashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Direct_RBC_HashDefaultTypeInternal() {}
  union {
    Direct_RBC_Hash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Direct_RBC_HashDefaultTypeInternal _Direct_RBC_Hash_default_instance_;
PROTOBUF_CONSTEXPR Direct_RBC::Direct_RBC(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tag_)*/nullptr
  , /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Direct_RBCDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Direct_RBCDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Direct_RBCDefaultTypeInternal() {}
  union {
    Direct_RBC _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Direct_RBCDefaultTypeInternal _Direct_RBC_default_instance_;
PROTOBUF_CONSTEXPR Direct_NoiseMessage::Direct_NoiseMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Direct_NoiseMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Direct_NoiseMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Direct_NoiseMessageDefaultTypeInternal() {}
  union {
    Direct_NoiseMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Direct_NoiseMessageDefaultTypeInternal _Direct_NoiseMessage_default_instance_;
PROTOBUF_CONSTEXPR Direct::Direct(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.committee_id_)*/0u
  , /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DirectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DirectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DirectDefaultTypeInternal() {}
  union {
    Direct _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirectDefaultTypeInternal _Direct_default_instance_;
PROTOBUF_CONSTEXPR Broadcast_Committee::Broadcast_Committee(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Broadcast_CommitteeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Broadcast_CommitteeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Broadcast_CommitteeDefaultTypeInternal() {}
  union {
    Broadcast_Committee _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Broadcast_CommitteeDefaultTypeInternal _Broadcast_Committee_default_instance_;
PROTOBUF_CONSTEXPR Broadcast_Complaints::Broadcast_Complaints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Broadcast_ComplaintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Broadcast_ComplaintsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Broadcast_ComplaintsDefaultTypeInternal() {}
  union {
    Broadcast_Complaints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Broadcast_ComplaintsDefaultTypeInternal _Broadcast_Complaints_default_instance_;
PROTOBUF_CONSTEXPR Broadcast_Shares::Broadcast_Shares(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_)*/{}
  , /*decltype(_impl_.second_)*/{}
  , /*decltype(_impl_.reporter_)*/{}
  , /*decltype(_impl_.phase_)*/uint64_t{0u}} {}
struct Broadcast_SharesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Broadcast_SharesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Broadcast_SharesDefaultTypeInternal() {}
  union {
    Broadcast_Shares _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Broadcast_SharesDefaultTypeInternal _Broadcast_Shares_default_instance_;
PROTOBUF_CONSTEXPR Broadcast_Coefficients::Broadcast_Coefficients(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.coefficients_)*/{}
  , /*decltype(_impl_.phase_)*/uint64_t{0u}} {}
struct Broadcast_CoefficientsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Broadcast_CoefficientsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Broadcast_CoefficientsDefaultTypeInternal() {}
  union {
    Broadcast_Coefficients _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Broadcast_CoefficientsDefaultTypeInternal _Broadcast_Coefficients_default_instance_;
PROTOBUF_CONSTEXPR Broadcast::Broadcast(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.payload_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BroadcastDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BroadcastDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BroadcastDefaultTypeInternal() {}
  union {
    Broadcast _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BroadcastDefaultTypeInternal _Broadcast_default_instance_;
}  // namespace pb
}  // namespace consensus
}  // namespace fetch
static ::_pb::Metadata file_level_metadata_consensus_2eproto[18];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_consensus_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_consensus_2eproto = nullptr;

const uint32_t TableStruct_consensus_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _impl_.public_key_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _impl_.dh_public_key_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Neighbour, _impl_.key_signature_),
  0,
  2,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::PrivateShares, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::PrivateShares, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::PrivateShares, _impl_.first_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::PrivateShares, _impl_.second_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Join, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Join, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _impl_.step_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _impl_.gossip_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _impl_.msg_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message_Gossip, _impl_.signature_),
  2,
  3,
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Message, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip_SignatureShare, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip_SignatureShare, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip_SignatureShare, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip_SignatureShare, _impl_.share_sig_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip_SignatureShare, _impl_.share_pi_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip_SignatureShare, _impl_.share_pi2_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Gossip, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Tag, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Tag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Tag, _impl_.channel_id_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Tag, _impl_.rank_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Tag, _impl_.seq_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Message, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Message, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Message, _impl_.message_),
  0,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Hash, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Hash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC_Hash, _impl_.msg_hash_),
  0,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC, _impl_.tag_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_RBC, _impl_.payload_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_NoiseMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct_NoiseMessage, _impl_.payload_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct, _impl_.committee_id_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Direct, _impl_.payload_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Committee, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Committee, _impl_.nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Complaints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Complaints, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Shares, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Shares, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Shares, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Shares, _impl_.first_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Shares, _impl_.second_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Shares, _impl_.reporter_),
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Coefficients, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Coefficients, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Coefficients, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast_Coefficients, _impl_.coefficients_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::fetch::consensus::pb::Broadcast, _impl_.payload_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::fetch::consensus::pb::Neighbour)},
  { 16, 24, -1, sizeof(::fetch::consensus::pb::PrivateShares)},
  { 26, -1, -1, sizeof(::fetch::consensus::pb::Message_Join)},
  { 33, 44, -1, sizeof(::fetch::consensus::pb::Message_Gossip)},
  { 49, -1, -1, sizeof(::fetch::consensus::pb::Message)},
  { 58, 68, -1, sizeof(::fetch::consensus::pb::Gossip_SignatureShare)},
  { 72, -1, -1, sizeof(::fetch::consensus::pb::Gossip)},
  { 80, 89, -1, sizeof(::fetch::consensus::pb::Direct_RBC_Tag)},
  { 92, 99, -1, sizeof(::fetch::consensus::pb::Direct_RBC_Message)},
  { 100, 107, -1, sizeof(::fetch::consensus::pb::Direct_RBC_Hash)},
  { 108, 121, -1, sizeof(::fetch::consensus::pb::Direct_RBC)},
  { 127, -1, -1, sizeof(::fetch::consensus::pb::Direct_NoiseMessage)},
  { 134, 145, -1, sizeof(::fetch::consensus::pb::Direct)},
  { 149, -1, -1, sizeof(::fetch::consensus::pb::Broadcast_Committee)},
  { 156, -1, -1, sizeof(::fetch::consensus::pb::Broadcast_Complaints)},
  { 163, 173, -1, sizeof(::fetch::consensus::pb::Broadcast_Shares)},
  { 177, 185, -1, sizeof(::fetch::consensus::pb::Broadcast_Coefficients)},
  { 187, -1, -1, sizeof(::fetch::consensus::pb::Broadcast)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::fetch::consensus::pb::_Neighbour_default_instance_._instance,
  &::fetch::consensus::pb::_PrivateShares_default_instance_._instance,
  &::fetch::consensus::pb::_Message_Join_default_instance_._instance,
  &::fetch::consensus::pb::_Message_Gossip_default_instance_._instance,
  &::fetch::consensus::pb::_Message_default_instance_._instance,
  &::fetch::consensus::pb::_Gossip_SignatureShare_default_instance_._instance,
  &::fetch::consensus::pb::_Gossip_default_instance_._instance,
  &::fetch::consensus::pb::_Direct_RBC_Tag_default_instance_._instance,
  &::fetch::consensus::pb::_Direct_RBC_Message_default_instance_._instance,
  &::fetch::consensus::pb::_Direct_RBC_Hash_default_instance_._instance,
  &::fetch::consensus::pb::_Direct_RBC_default_instance_._instance,
  &::fetch::consensus::pb::_Direct_NoiseMessage_default_instance_._instance,
  &::fetch::consensus::pb::_Direct_default_instance_._instance,
  &::fetch::consensus::pb::_Broadcast_Committee_default_instance_._instance,
  &::fetch::consensus::pb::_Broadcast_Complaints_default_instance_._instance,
  &::fetch::consensus::pb::_Broadcast_Shares_default_instance_._instance,
  &::fetch::consensus::pb::_Broadcast_Coefficients_default_instance_._instance,
  &::fetch::consensus::pb::_Broadcast_default_instance_._instance,
};

const char descriptor_table_protodef_consensus_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017consensus.proto\022\022fetch.consensus.pb\"g\n"
  "\tNeighbour\022\n\n\002id\030\001 \002(\t\022\014\n\004port\030\002 \002(\r\022\022\n\n"
  "public_key\030\003 \002(\t\022\025\n\rdh_public_key\030\004 \003(\r\022"
  "\025\n\rkey_signature\030\005 \003(\r\".\n\rPrivateShares\022"
  "\r\n\005first\030\001 \002(\t\022\016\n\006second\030\002 \002(\t\"\353\001\n\007Messa"
  "ge\0220\n\004join\030\001 \001(\0132 .fetch.consensus.pb.Me"
  "ssage.JoinH\000\0224\n\006gossip\030\002 \001(\0132\".fetch.con"
  "sensus.pb.Message.GossipH\000\032\025\n\004Join\022\r\n\005no"
  "des\030\001 \003(\t\032V\n\006Gossip\022\014\n\004step\030\001 \002(\004\022\016\n\006gos"
  "sip\030\002 \002(\010\022\013\n\003msg\030\003 \002(\014\022\016\n\006origin\030\004 \002(\t\022\021"
  "\n\tsignature\030\005 \003(\rB\t\n\007payload\"\256\001\n\006Gossip\022"
  ">\n\tsig_share\030\001 \001(\0132).fetch.consensus.pb."
  "Gossip.SignatureShareH\000\032Y\n\016SignatureShar"
  "e\022\017\n\007message\030\001 \002(\t\022\021\n\tshare_sig\030\002 \002(\t\022\020\n"
  "\010share_pi\030\003 \001(\t\022\021\n\tshare_pi2\030\004 \001(\tB\t\n\007pa"
  "yload\"\312\005\n\006Direct\022\024\n\014committee_id\030\001 \002(\r\0221"
  "\n\007rbc_msg\030\002 \001(\0132\036.fetch.consensus.pb.Dir"
  "ect.RBCH\000\022<\n\thandshake\030\003 \001(\0132\'.fetch.con"
  "sensus.pb.Direct.NoiseMessageH\000\022C\n\020encry"
  "pted_cipher\030\004 \001(\0132\'.fetch.consensus.pb.D"
  "irect.NoiseMessageH\000\032\307\003\n\003RBC\022/\n\003tag\030\001 \002("
  "\0132\".fetch.consensus.pb.Direct.RBC.Tag\022;\n"
  "\tbroadcast\030\002 \001(\0132&.fetch.consensus.pb.Di"
  "rect.RBC.MessageH\000\0223\n\004echo\030\003 \001(\0132#.fetch"
  ".consensus.pb.Direct.RBC.HashH\000\0224\n\005ready"
  "\030\004 \001(\0132#.fetch.consensus.pb.Direct.RBC.H"
  "ashH\000\0226\n\007request\030\005 \001(\0132#.fetch.consensus"
  ".pb.Direct.RBC.HashH\000\0228\n\006answer\030\006 \001(\0132&."
  "fetch.consensus.pb.Direct.RBC.MessageH\000\032"
  "4\n\003Tag\022\022\n\nchannel_id\030\001 \002(\r\022\014\n\004rank\030\002 \002(\r"
  "\022\013\n\003seq\030\003 \002(\r\032\032\n\007Message\022\017\n\007message\030\002 \002("
  "\014\032\030\n\004Hash\022\020\n\010msg_hash\030\002 \002(\tB\t\n\007payload\032\037"
  "\n\014NoiseMessage\022\017\n\007payload\030\001 \003(\rB\t\n\007paylo"
  "ad\"\310\003\n\tBroadcast\022>\n\ncomplaints\030\001 \001(\0132(.f"
  "etch.consensus.pb.Broadcast.ComplaintsH\000"
  "\0226\n\006shares\030\002 \001(\0132$.fetch.consensus.pb.Br"
  "oadcast.SharesH\000\022B\n\014coefficients\030\003 \001(\0132*"
  ".fetch.consensus.pb.Broadcast.Coefficien"
  "tsH\000\022<\n\tcommittee\030\004 \001(\0132\'.fetch.consensu"
  "s.pb.Broadcast.CommitteeH\000\032\032\n\tCommittee\022"
  "\r\n\005nodes\030\001 \003(\t\032\033\n\nComplaints\022\r\n\005nodes\030\001 "
  "\003(\t\032H\n\006Shares\022\r\n\005phase\030\001 \002(\004\022\r\n\005first\030\002 "
  "\003(\t\022\016\n\006second\030\003 \003(\t\022\020\n\010reporter\030\004 \003(\t\0323\n"
  "\014Coefficients\022\r\n\005phase\030\001 \002(\004\022\024\n\014coeffici"
  "ents\030\002 \003(\tB\t\n\007payloadB\002H\001"
  ;
static ::_pbi::once_flag descriptor_table_consensus_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_consensus_2eproto = {
    false, false, 1785, descriptor_table_protodef_consensus_2eproto,
    "consensus.proto",
    &descriptor_table_consensus_2eproto_once, nullptr, 0, 18,
    schemas, file_default_instances, TableStruct_consensus_2eproto::offsets,
    file_level_metadata_consensus_2eproto, file_level_enum_descriptors_consensus_2eproto,
    file_level_service_descriptors_consensus_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_consensus_2eproto_getter() {
  return &descriptor_table_consensus_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_consensus_2eproto(&descriptor_table_consensus_2eproto);
namespace fetch {
namespace consensus {
namespace pb {

// ===================================================================

class Neighbour::_Internal {
 public:
  using HasBits = decltype(std::declval<Neighbour>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_public_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Neighbour::Neighbour(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Neighbour)
}
Neighbour::Neighbour(const Neighbour& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Neighbour* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dh_public_key_){from._impl_.dh_public_key_}
    , decltype(_impl_.key_signature_){from._impl_.key_signature_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_key()) {
    _this->_impl_.public_key_.Set(from._internal_public_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Neighbour)
}

inline void Neighbour::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dh_public_key_){arena}
    , decltype(_impl_.key_signature_){arena}
    , decltype(_impl_.id_){}
    , decltype(_impl_.public_key_){}
    , decltype(_impl_.port_){0u}
  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.public_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Neighbour::~Neighbour() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Neighbour)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Neighbour::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dh_public_key_.~RepeatedField();
  _impl_.key_signature_.~RepeatedField();
  _impl_.id_.Destroy();
  _impl_.public_key_.Destroy();
}

void Neighbour::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Neighbour::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Neighbour)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dh_public_key_.Clear();
  _impl_.key_signature_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.public_key_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.port_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neighbour::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Neighbour.id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string public_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_public_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Neighbour.public_key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 dh_public_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dh_public_key(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_dh_public_key(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 key_signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_key_signature(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_key_signature(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Neighbour::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Neighbour)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Neighbour.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // required uint32 port = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  // required string public_key = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_public_key().data(), static_cast<int>(this->_internal_public_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Neighbour.public_key");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_public_key(), target);
  }

  // repeated uint32 dh_public_key = 4;
  for (int i = 0, n = this->_internal_dh_public_key_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dh_public_key(i), target);
  }

  // repeated uint32 key_signature = 5;
  for (int i = 0, n = this->_internal_key_signature_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_key_signature(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Neighbour)
  return target;
}

size_t Neighbour::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:fetch.consensus.pb.Neighbour)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  if (_internal_has_public_key()) {
    // required string public_key = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_public_key());
  }

  if (_internal_has_port()) {
    // required uint32 port = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return total_size;
}
size_t Neighbour::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Neighbour)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());

    // required string public_key = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_public_key());

    // required uint32 port = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 dh_public_key = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.dh_public_key_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dh_public_key_size());
    total_size += data_size;
  }

  // repeated uint32 key_signature = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.key_signature_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_key_signature_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Neighbour::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Neighbour::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Neighbour::GetClassData() const { return &_class_data_; }


void Neighbour::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Neighbour*>(&to_msg);
  auto& from = static_cast<const Neighbour&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Neighbour)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dh_public_key_.MergeFrom(from._impl_.dh_public_key_);
  _this->_impl_.key_signature_.MergeFrom(from._impl_.key_signature_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_public_key(from._internal_public_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Neighbour::CopyFrom(const Neighbour& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Neighbour)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neighbour::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Neighbour::InternalSwap(Neighbour* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dh_public_key_.InternalSwap(&other->_impl_.dh_public_key_);
  _impl_.key_signature_.InternalSwap(&other->_impl_.key_signature_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.public_key_, lhs_arena,
      &other->_impl_.public_key_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Neighbour::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[0]);
}

// ===================================================================

class PrivateShares::_Internal {
 public:
  using HasBits = decltype(std::declval<PrivateShares>()._impl_._has_bits_);
  static void set_has_first(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_second(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

PrivateShares::PrivateShares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.PrivateShares)
}
PrivateShares::PrivateShares(const PrivateShares& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PrivateShares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_){}
    , decltype(_impl_.second_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.first_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_first()) {
    _this->_impl_.first_.Set(from._internal_first(), 
      _this->GetArenaForAllocation());
  }
  _impl_.second_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.second_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_second()) {
    _this->_impl_.second_.Set(from._internal_second(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.PrivateShares)
}

inline void PrivateShares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_){}
    , decltype(_impl_.second_){}
  };
  _impl_.first_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.second_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.second_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PrivateShares::~PrivateShares() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.PrivateShares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrivateShares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.first_.Destroy();
  _impl_.second_.Destroy();
}

void PrivateShares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrivateShares::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.PrivateShares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.first_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.second_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrivateShares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string first = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_first();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.PrivateShares.first");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string second = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_second();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.PrivateShares.second");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrivateShares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.PrivateShares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string first = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_first().data(), static_cast<int>(this->_internal_first().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.PrivateShares.first");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_first(), target);
  }

  // required string second = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_second().data(), static_cast<int>(this->_internal_second().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.PrivateShares.second");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_second(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.PrivateShares)
  return target;
}

size_t PrivateShares::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:fetch.consensus.pb.PrivateShares)
  size_t total_size = 0;

  if (_internal_has_first()) {
    // required string first = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_first());
  }

  if (_internal_has_second()) {
    // required string second = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_second());
  }

  return total_size;
}
size_t PrivateShares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.PrivateShares)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string first = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_first());

    // required string second = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_second());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrivateShares::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PrivateShares::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrivateShares::GetClassData() const { return &_class_data_; }


void PrivateShares::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PrivateShares*>(&to_msg);
  auto& from = static_cast<const PrivateShares&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.PrivateShares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_first(from._internal_first());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_second(from._internal_second());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrivateShares::CopyFrom(const PrivateShares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.PrivateShares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrivateShares::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PrivateShares::InternalSwap(PrivateShares* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.first_, lhs_arena,
      &other->_impl_.first_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.second_, lhs_arena,
      &other->_impl_.second_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PrivateShares::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[1]);
}

// ===================================================================

class Message_Join::_Internal {
 public:
};

Message_Join::Message_Join(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Message.Join)
}
Message_Join::Message_Join(const Message_Join& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message_Join* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Message.Join)
}

inline void Message_Join::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Message_Join::~Message_Join() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Message.Join)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message_Join::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void Message_Join::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message_Join::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Message.Join)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message_Join::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Message.Join.nodes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message_Join::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Message.Join)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string nodes = 1;
  for (int i = 0, n = this->_internal_nodes_size(); i < n; i++) {
    const auto& s = this->_internal_nodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Message.Join.nodes");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Message.Join)
  return target;
}

size_t Message_Join::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Message.Join)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string nodes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.nodes_.size());
  for (int i = 0, n = _impl_.nodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.nodes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message_Join::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message_Join::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message_Join::GetClassData() const { return &_class_data_; }


void Message_Join::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message_Join*>(&to_msg);
  auto& from = static_cast<const Message_Join&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Message.Join)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message_Join::CopyFrom(const Message_Join& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Message.Join)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message_Join::IsInitialized() const {
  return true;
}

void Message_Join::InternalSwap(Message_Join* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Message_Join::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[2]);
}

// ===================================================================

class Message_Gossip::_Internal {
 public:
  using HasBits = decltype(std::declval<Message_Gossip>()._impl_._has_bits_);
  static void set_has_step(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gossip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

Message_Gossip::Message_Gossip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Message.Gossip)
}
Message_Gossip::Message_Gossip(const Message_Gossip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message_Gossip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signature_){from._impl_.signature_}
    , decltype(_impl_.msg_){}
    , decltype(_impl_.origin_){}
    , decltype(_impl_.step_){}
    , decltype(_impl_.gossip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg()) {
    _this->_impl_.msg_.Set(from._internal_msg(), 
      _this->GetArenaForAllocation());
  }
  _impl_.origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_origin()) {
    _this->_impl_.origin_.Set(from._internal_origin(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.step_, &from._impl_.step_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gossip_) -
    reinterpret_cast<char*>(&_impl_.step_)) + sizeof(_impl_.gossip_));
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Message.Gossip)
}

inline void Message_Gossip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signature_){arena}
    , decltype(_impl_.msg_){}
    , decltype(_impl_.origin_){}
    , decltype(_impl_.step_){uint64_t{0u}}
    , decltype(_impl_.gossip_){false}
  };
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.origin_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Message_Gossip::~Message_Gossip() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Message.Gossip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message_Gossip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signature_.~RepeatedField();
  _impl_.msg_.Destroy();
  _impl_.origin_.Destroy();
}

void Message_Gossip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message_Gossip::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Message.Gossip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.signature_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.msg_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.origin_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.step_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.gossip_) -
        reinterpret_cast<char*>(&_impl_.step_)) + sizeof(_impl_.gossip_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message_Gossip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 step = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_step(&has_bits);
          _impl_.step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool gossip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gossip(&has_bits);
          _impl_.gossip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes msg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string origin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_origin();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Message.Gossip.origin");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_signature(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_signature(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message_Gossip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Message.Gossip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 step = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_step(), target);
  }

  // required bool gossip = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_gossip(), target);
  }

  // required bytes msg = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_msg(), target);
  }

  // required string origin = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_origin().data(), static_cast<int>(this->_internal_origin().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Message.Gossip.origin");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_origin(), target);
  }

  // repeated uint32 signature = 5;
  for (int i = 0, n = this->_internal_signature_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_signature(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Message.Gossip)
  return target;
}

size_t Message_Gossip::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:fetch.consensus.pb.Message.Gossip)
  size_t total_size = 0;

  if (_internal_has_msg()) {
    // required bytes msg = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg());
  }

  if (_internal_has_origin()) {
    // required string origin = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_origin());
  }

  if (_internal_has_step()) {
    // required uint64 step = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_step());
  }

  if (_internal_has_gossip()) {
    // required bool gossip = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t Message_Gossip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Message.Gossip)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes msg = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_msg());

    // required string origin = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_origin());

    // required uint64 step = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_step());

    // required bool gossip = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 signature = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.signature_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_signature_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message_Gossip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message_Gossip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message_Gossip::GetClassData() const { return &_class_data_; }


void Message_Gossip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message_Gossip*>(&to_msg);
  auto& from = static_cast<const Message_Gossip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Message.Gossip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.signature_.MergeFrom(from._impl_.signature_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg(from._internal_msg());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_origin(from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.step_ = from._impl_.step_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.gossip_ = from._impl_.gossip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message_Gossip::CopyFrom(const Message_Gossip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Message.Gossip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message_Gossip::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Message_Gossip::InternalSwap(Message_Gossip* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.signature_.InternalSwap(&other->_impl_.signature_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_, lhs_arena,
      &other->_impl_.msg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.origin_, lhs_arena,
      &other->_impl_.origin_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Message_Gossip, _impl_.gossip_)
      + sizeof(Message_Gossip::_impl_.gossip_)
      - PROTOBUF_FIELD_OFFSET(Message_Gossip, _impl_.step_)>(
          reinterpret_cast<char*>(&_impl_.step_),
          reinterpret_cast<char*>(&other->_impl_.step_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Message_Gossip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[3]);
}

// ===================================================================

class Message::_Internal {
 public:
  static const ::fetch::consensus::pb::Message_Join& join(const Message* msg);
  static const ::fetch::consensus::pb::Message_Gossip& gossip(const Message* msg);
};

const ::fetch::consensus::pb::Message_Join&
Message::_Internal::join(const Message* msg) {
  return *msg->_impl_.payload_.join_;
}
const ::fetch::consensus::pb::Message_Gossip&
Message::_Internal::gossip(const Message* msg) {
  return *msg->_impl_.payload_.gossip_;
}
void Message::set_allocated_join(::fetch::consensus::pb::Message_Join* join) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (join) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(join);
    if (message_arena != submessage_arena) {
      join = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join, submessage_arena);
    }
    set_has_join();
    _impl_.payload_.join_ = join;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Message.join)
}
void Message::set_allocated_gossip(::fetch::consensus::pb::Message_Gossip* gossip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (gossip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gossip);
    if (message_arena != submessage_arena) {
      gossip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gossip, submessage_arena);
    }
    set_has_gossip();
    _impl_.payload_.gossip_ = gossip;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Message.gossip)
}
Message::Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Message)
}
Message::Message(const Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_payload();
  switch (from.payload_case()) {
    case kJoin: {
      _this->_internal_mutable_join()->::fetch::consensus::pb::Message_Join::MergeFrom(
          from._internal_join());
      break;
    }
    case kGossip: {
      _this->_internal_mutable_gossip()->::fetch::consensus::pb::Message_Gossip::MergeFrom(
          from._internal_gossip());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Message)
}

inline void Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Message::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:fetch.consensus.pb.Message)
  switch (payload_case()) {
    case kJoin: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.join_;
      }
      break;
    }
    case kGossip: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.gossip_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .fetch.consensus.pb.Message.Join join = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_join(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Message.Gossip gossip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gossip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (payload_case()) {
    case kJoin: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::join(this),
          _Internal::join(this).GetCachedSize(), target, stream);
      break;
    }
    case kGossip: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::gossip(this),
          _Internal::gossip(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Message)
  return target;
}

size_t Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Message)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .fetch.consensus.pb.Message.Join join = 1;
    case kJoin: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.join_);
      break;
    }
    // .fetch.consensus.pb.Message.Gossip gossip = 2;
    case kGossip: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.gossip_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Message::GetClassData() const { return &_class_data_; }


void Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Message*>(&to_msg);
  auto& from = static_cast<const Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.payload_case()) {
    case kJoin: {
      _this->_internal_mutable_join()->::fetch::consensus::pb::Message_Join::MergeFrom(
          from._internal_join());
      break;
    }
    case kGossip: {
      _this->_internal_mutable_gossip()->::fetch::consensus::pb::Message_Gossip::MergeFrom(
          from._internal_gossip());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  switch (payload_case()) {
    case kJoin: {
      break;
    }
    case kGossip: {
      if (_internal_has_gossip()) {
        if (!_impl_.payload_.gossip_->IsInitialized()) return false;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void Message::InternalSwap(Message* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[4]);
}

// ===================================================================

class Gossip_SignatureShare::_Internal {
 public:
  using HasBits = decltype(std::declval<Gossip_SignatureShare>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_share_sig(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_share_pi(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_share_pi2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Gossip_SignatureShare::Gossip_SignatureShare(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Gossip.SignatureShare)
}
Gossip_SignatureShare::Gossip_SignatureShare(const Gossip_SignatureShare& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Gossip_SignatureShare* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.share_sig_){}
    , decltype(_impl_.share_pi_){}
    , decltype(_impl_.share_pi2_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.share_sig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_sig_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_share_sig()) {
    _this->_impl_.share_sig_.Set(from._internal_share_sig(), 
      _this->GetArenaForAllocation());
  }
  _impl_.share_pi_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_pi_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_share_pi()) {
    _this->_impl_.share_pi_.Set(from._internal_share_pi(), 
      _this->GetArenaForAllocation());
  }
  _impl_.share_pi2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_pi2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_share_pi2()) {
    _this->_impl_.share_pi2_.Set(from._internal_share_pi2(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Gossip.SignatureShare)
}

inline void Gossip_SignatureShare::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
    , decltype(_impl_.share_sig_){}
    , decltype(_impl_.share_pi_){}
    , decltype(_impl_.share_pi2_){}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.share_sig_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_sig_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.share_pi_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_pi_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.share_pi2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_pi2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Gossip_SignatureShare::~Gossip_SignatureShare() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Gossip.SignatureShare)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Gossip_SignatureShare::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.share_sig_.Destroy();
  _impl_.share_pi_.Destroy();
  _impl_.share_pi2_.Destroy();
}

void Gossip_SignatureShare::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Gossip_SignatureShare::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Gossip.SignatureShare)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.share_sig_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.share_pi_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.share_pi2_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Gossip_SignatureShare::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Gossip.SignatureShare.message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string share_sig = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_share_sig();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Gossip.SignatureShare.share_sig");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string share_pi = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_share_pi();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Gossip.SignatureShare.share_pi");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string share_pi2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_share_pi2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Gossip.SignatureShare.share_pi2");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Gossip_SignatureShare::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Gossip.SignatureShare)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Gossip.SignatureShare.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // required string share_sig = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_share_sig().data(), static_cast<int>(this->_internal_share_sig().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Gossip.SignatureShare.share_sig");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_share_sig(), target);
  }

  // optional string share_pi = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_share_pi().data(), static_cast<int>(this->_internal_share_pi().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Gossip.SignatureShare.share_pi");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_share_pi(), target);
  }

  // optional string share_pi2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_share_pi2().data(), static_cast<int>(this->_internal_share_pi2().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Gossip.SignatureShare.share_pi2");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_share_pi2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Gossip.SignatureShare)
  return target;
}

size_t Gossip_SignatureShare::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:fetch.consensus.pb.Gossip.SignatureShare)
  size_t total_size = 0;

  if (_internal_has_message()) {
    // required string message = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (_internal_has_share_sig()) {
    // required string share_sig = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_share_sig());
  }

  return total_size;
}
size_t Gossip_SignatureShare::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Gossip.SignatureShare)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string message = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());

    // required string share_sig = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_share_sig());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional string share_pi = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_share_pi());
    }

    // optional string share_pi2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_share_pi2());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Gossip_SignatureShare::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Gossip_SignatureShare::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Gossip_SignatureShare::GetClassData() const { return &_class_data_; }


void Gossip_SignatureShare::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Gossip_SignatureShare*>(&to_msg);
  auto& from = static_cast<const Gossip_SignatureShare&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Gossip.SignatureShare)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_share_sig(from._internal_share_sig());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_share_pi(from._internal_share_pi());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_share_pi2(from._internal_share_pi2());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Gossip_SignatureShare::CopyFrom(const Gossip_SignatureShare& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Gossip.SignatureShare)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gossip_SignatureShare::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Gossip_SignatureShare::InternalSwap(Gossip_SignatureShare* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.share_sig_, lhs_arena,
      &other->_impl_.share_sig_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.share_pi_, lhs_arena,
      &other->_impl_.share_pi_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.share_pi2_, lhs_arena,
      &other->_impl_.share_pi2_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Gossip_SignatureShare::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[5]);
}

// ===================================================================

class Gossip::_Internal {
 public:
  static const ::fetch::consensus::pb::Gossip_SignatureShare& sig_share(const Gossip* msg);
};

const ::fetch::consensus::pb::Gossip_SignatureShare&
Gossip::_Internal::sig_share(const Gossip* msg) {
  return *msg->_impl_.payload_.sig_share_;
}
void Gossip::set_allocated_sig_share(::fetch::consensus::pb::Gossip_SignatureShare* sig_share) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (sig_share) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sig_share);
    if (message_arena != submessage_arena) {
      sig_share = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sig_share, submessage_arena);
    }
    set_has_sig_share();
    _impl_.payload_.sig_share_ = sig_share;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Gossip.sig_share)
}
Gossip::Gossip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Gossip)
}
Gossip::Gossip(const Gossip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Gossip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_payload();
  switch (from.payload_case()) {
    case kSigShare: {
      _this->_internal_mutable_sig_share()->::fetch::consensus::pb::Gossip_SignatureShare::MergeFrom(
          from._internal_sig_share());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Gossip)
}

inline void Gossip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

Gossip::~Gossip() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Gossip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Gossip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void Gossip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Gossip::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:fetch.consensus.pb.Gossip)
  switch (payload_case()) {
    case kSigShare: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.sig_share_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Gossip::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Gossip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Gossip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .fetch.consensus.pb.Gossip.SignatureShare sig_share = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sig_share(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Gossip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Gossip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .fetch.consensus.pb.Gossip.SignatureShare sig_share = 1;
  if (_internal_has_sig_share()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sig_share(this),
        _Internal::sig_share(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Gossip)
  return target;
}

size_t Gossip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Gossip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .fetch.consensus.pb.Gossip.SignatureShare sig_share = 1;
    case kSigShare: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.sig_share_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Gossip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Gossip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Gossip::GetClassData() const { return &_class_data_; }


void Gossip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Gossip*>(&to_msg);
  auto& from = static_cast<const Gossip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Gossip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.payload_case()) {
    case kSigShare: {
      _this->_internal_mutable_sig_share()->::fetch::consensus::pb::Gossip_SignatureShare::MergeFrom(
          from._internal_sig_share());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Gossip::CopyFrom(const Gossip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Gossip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gossip::IsInitialized() const {
  switch (payload_case()) {
    case kSigShare: {
      if (_internal_has_sig_share()) {
        if (!_impl_.payload_.sig_share_->IsInitialized()) return false;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void Gossip::InternalSwap(Gossip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Gossip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[6]);
}

// ===================================================================

class Direct_RBC_Tag::_Internal {
 public:
  using HasBits = decltype(std::declval<Direct_RBC_Tag>()._impl_._has_bits_);
  static void set_has_channel_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Direct_RBC_Tag::Direct_RBC_Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Direct.RBC.Tag)
}
Direct_RBC_Tag::Direct_RBC_Tag(const Direct_RBC_Tag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Direct_RBC_Tag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_id_){}
    , decltype(_impl_.rank_){}
    , decltype(_impl_.seq_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.channel_id_, &from._impl_.channel_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.seq_) -
    reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.seq_));
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Direct.RBC.Tag)
}

inline void Direct_RBC_Tag::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.channel_id_){0u}
    , decltype(_impl_.rank_){0u}
    , decltype(_impl_.seq_){0u}
  };
}

Direct_RBC_Tag::~Direct_RBC_Tag() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Direct.RBC.Tag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Direct_RBC_Tag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Direct_RBC_Tag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Direct_RBC_Tag::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Direct.RBC.Tag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.channel_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.seq_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.seq_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Direct_RBC_Tag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 channel_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel_id(&has_bits);
          _impl_.channel_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 rank = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rank(&has_bits);
          _impl_.rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 seq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seq(&has_bits);
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Direct_RBC_Tag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Direct.RBC.Tag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 channel_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel_id(), target);
  }

  // required uint32 rank = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rank(), target);
  }

  // required uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Direct.RBC.Tag)
  return target;
}

size_t Direct_RBC_Tag::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:fetch.consensus.pb.Direct.RBC.Tag)
  size_t total_size = 0;

  if (_internal_has_channel_id()) {
    // required uint32 channel_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel_id());
  }

  if (_internal_has_rank()) {
    // required uint32 rank = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());
  }

  if (_internal_has_seq()) {
    // required uint32 seq = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq());
  }

  return total_size;
}
size_t Direct_RBC_Tag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Direct.RBC.Tag)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 channel_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel_id());

    // required uint32 rank = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());

    // required uint32 seq = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Direct_RBC_Tag::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Direct_RBC_Tag::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Direct_RBC_Tag::GetClassData() const { return &_class_data_; }


void Direct_RBC_Tag::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Direct_RBC_Tag*>(&to_msg);
  auto& from = static_cast<const Direct_RBC_Tag&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Direct.RBC.Tag)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rank_ = from._impl_.rank_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.seq_ = from._impl_.seq_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Direct_RBC_Tag::CopyFrom(const Direct_RBC_Tag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Direct.RBC.Tag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Direct_RBC_Tag::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Direct_RBC_Tag::InternalSwap(Direct_RBC_Tag* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Direct_RBC_Tag, _impl_.seq_)
      + sizeof(Direct_RBC_Tag::_impl_.seq_)
      - PROTOBUF_FIELD_OFFSET(Direct_RBC_Tag, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Direct_RBC_Tag::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[7]);
}

// ===================================================================

class Direct_RBC_Message::_Internal {
 public:
  using HasBits = decltype(std::declval<Direct_RBC_Message>()._impl_._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Direct_RBC_Message::Direct_RBC_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Direct.RBC.Message)
}
Direct_RBC_Message::Direct_RBC_Message(const Direct_RBC_Message& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Direct_RBC_Message* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Direct.RBC.Message)
}

inline void Direct_RBC_Message::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_){}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Direct_RBC_Message::~Direct_RBC_Message() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Direct.RBC.Message)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Direct_RBC_Message::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
}

void Direct_RBC_Message::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Direct_RBC_Message::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Direct.RBC.Message)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Direct_RBC_Message::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Direct_RBC_Message::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Direct.RBC.Message)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Direct.RBC.Message)
  return target;
}

size_t Direct_RBC_Message::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Direct.RBC.Message)
  size_t total_size = 0;

  // required bytes message = 2;
  if (_internal_has_message()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_message());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Direct_RBC_Message::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Direct_RBC_Message::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Direct_RBC_Message::GetClassData() const { return &_class_data_; }


void Direct_RBC_Message::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Direct_RBC_Message*>(&to_msg);
  auto& from = static_cast<const Direct_RBC_Message&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Direct.RBC.Message)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _this->_internal_set_message(from._internal_message());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Direct_RBC_Message::CopyFrom(const Direct_RBC_Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Direct.RBC.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Direct_RBC_Message::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Direct_RBC_Message::InternalSwap(Direct_RBC_Message* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Direct_RBC_Message::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[8]);
}

// ===================================================================

class Direct_RBC_Hash::_Internal {
 public:
  using HasBits = decltype(std::declval<Direct_RBC_Hash>()._impl_._has_bits_);
  static void set_has_msg_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Direct_RBC_Hash::Direct_RBC_Hash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Direct.RBC.Hash)
}
Direct_RBC_Hash::Direct_RBC_Hash(const Direct_RBC_Hash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Direct_RBC_Hash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_hash_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.msg_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_hash()) {
    _this->_impl_.msg_hash_.Set(from._internal_msg_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Direct.RBC.Hash)
}

inline void Direct_RBC_Hash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_hash_){}
  };
  _impl_.msg_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Direct_RBC_Hash::~Direct_RBC_Hash() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Direct.RBC.Hash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Direct_RBC_Hash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_hash_.Destroy();
}

void Direct_RBC_Hash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Direct_RBC_Hash::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Direct.RBC.Hash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_hash_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Direct_RBC_Hash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string msg_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_msg_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Direct.RBC.Hash.msg_hash");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Direct_RBC_Hash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Direct.RBC.Hash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string msg_hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_msg_hash().data(), static_cast<int>(this->_internal_msg_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Direct.RBC.Hash.msg_hash");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_msg_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Direct.RBC.Hash)
  return target;
}

size_t Direct_RBC_Hash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Direct.RBC.Hash)
  size_t total_size = 0;

  // required string msg_hash = 2;
  if (_internal_has_msg_hash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg_hash());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Direct_RBC_Hash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Direct_RBC_Hash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Direct_RBC_Hash::GetClassData() const { return &_class_data_; }


void Direct_RBC_Hash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Direct_RBC_Hash*>(&to_msg);
  auto& from = static_cast<const Direct_RBC_Hash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Direct.RBC.Hash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_msg_hash()) {
    _this->_internal_set_msg_hash(from._internal_msg_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Direct_RBC_Hash::CopyFrom(const Direct_RBC_Hash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Direct.RBC.Hash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Direct_RBC_Hash::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Direct_RBC_Hash::InternalSwap(Direct_RBC_Hash* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_hash_, lhs_arena,
      &other->_impl_.msg_hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Direct_RBC_Hash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[9]);
}

// ===================================================================

class Direct_RBC::_Internal {
 public:
  using HasBits = decltype(std::declval<Direct_RBC>()._impl_._has_bits_);
  static const ::fetch::consensus::pb::Direct_RBC_Tag& tag(const Direct_RBC* msg);
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::fetch::consensus::pb::Direct_RBC_Message& broadcast(const Direct_RBC* msg);
  static const ::fetch::consensus::pb::Direct_RBC_Hash& echo(const Direct_RBC* msg);
  static const ::fetch::consensus::pb::Direct_RBC_Hash& ready(const Direct_RBC* msg);
  static const ::fetch::consensus::pb::Direct_RBC_Hash& request(const Direct_RBC* msg);
  static const ::fetch::consensus::pb::Direct_RBC_Message& answer(const Direct_RBC* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::fetch::consensus::pb::Direct_RBC_Tag&
Direct_RBC::_Internal::tag(const Direct_RBC* msg) {
  return *msg->_impl_.tag_;
}
const ::fetch::consensus::pb::Direct_RBC_Message&
Direct_RBC::_Internal::broadcast(const Direct_RBC* msg) {
  return *msg->_impl_.payload_.broadcast_;
}
const ::fetch::consensus::pb::Direct_RBC_Hash&
Direct_RBC::_Internal::echo(const Direct_RBC* msg) {
  return *msg->_impl_.payload_.echo_;
}
const ::fetch::consensus::pb::Direct_RBC_Hash&
Direct_RBC::_Internal::ready(const Direct_RBC* msg) {
  return *msg->_impl_.payload_.ready_;
}
const ::fetch::consensus::pb::Direct_RBC_Hash&
Direct_RBC::_Internal::request(const Direct_RBC* msg) {
  return *msg->_impl_.payload_.request_;
}
const ::fetch::consensus::pb::Direct_RBC_Message&
Direct_RBC::_Internal::answer(const Direct_RBC* msg) {
  return *msg->_impl_.payload_.answer_;
}
void Direct_RBC::set_allocated_broadcast(::fetch::consensus::pb::Direct_RBC_Message* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    set_has_broadcast();
    _impl_.payload_.broadcast_ = broadcast;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.broadcast)
}
void Direct_RBC::set_allocated_echo(::fetch::consensus::pb::Direct_RBC_Hash* echo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (echo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(echo);
    if (message_arena != submessage_arena) {
      echo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, echo, submessage_arena);
    }
    set_has_echo();
    _impl_.payload_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.echo)
}
void Direct_RBC::set_allocated_ready(::fetch::consensus::pb::Direct_RBC_Hash* ready) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (ready) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ready);
    if (message_arena != submessage_arena) {
      ready = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ready, submessage_arena);
    }
    set_has_ready();
    _impl_.payload_.ready_ = ready;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.ready)
}
void Direct_RBC::set_allocated_request(::fetch::consensus::pb::Direct_RBC_Hash* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    set_has_request();
    _impl_.payload_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.request)
}
void Direct_RBC::set_allocated_answer(::fetch::consensus::pb::Direct_RBC_Message* answer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (answer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(answer);
    if (message_arena != submessage_arena) {
      answer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, answer, submessage_arena);
    }
    set_has_answer();
    _impl_.payload_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.answer)
}
Direct_RBC::Direct_RBC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Direct.RBC)
}
Direct_RBC::Direct_RBC(const Direct_RBC& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Direct_RBC* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){nullptr}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tag()) {
    _this->_impl_.tag_ = new ::fetch::consensus::pb::Direct_RBC_Tag(*from._impl_.tag_);
  }
  clear_has_payload();
  switch (from.payload_case()) {
    case kBroadcast: {
      _this->_internal_mutable_broadcast()->::fetch::consensus::pb::Direct_RBC_Message::MergeFrom(
          from._internal_broadcast());
      break;
    }
    case kEcho: {
      _this->_internal_mutable_echo()->::fetch::consensus::pb::Direct_RBC_Hash::MergeFrom(
          from._internal_echo());
      break;
    }
    case kReady: {
      _this->_internal_mutable_ready()->::fetch::consensus::pb::Direct_RBC_Hash::MergeFrom(
          from._internal_ready());
      break;
    }
    case kRequest: {
      _this->_internal_mutable_request()->::fetch::consensus::pb::Direct_RBC_Hash::MergeFrom(
          from._internal_request());
      break;
    }
    case kAnswer: {
      _this->_internal_mutable_answer()->::fetch::consensus::pb::Direct_RBC_Message::MergeFrom(
          from._internal_answer());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Direct.RBC)
}

inline void Direct_RBC::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tag_){nullptr}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

Direct_RBC::~Direct_RBC() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Direct.RBC)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Direct_RBC::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tag_;
  if (has_payload()) {
    clear_payload();
  }
}

void Direct_RBC::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Direct_RBC::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:fetch.consensus.pb.Direct.RBC)
  switch (payload_case()) {
    case kBroadcast: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.broadcast_;
      }
      break;
    }
    case kEcho: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.echo_;
      }
      break;
    }
    case kReady: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.ready_;
      }
      break;
    }
    case kRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.request_;
      }
      break;
    }
    case kAnswer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.answer_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Direct_RBC::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Direct.RBC)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tag_ != nullptr);
    _impl_.tag_->Clear();
  }
  clear_payload();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Direct_RBC::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .fetch.consensus.pb.Direct.RBC.Tag tag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tag(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.RBC.Message broadcast = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_broadcast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.RBC.Hash echo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_echo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.RBC.Hash ready = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ready(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.RBC.Hash request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.RBC.Message answer = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_answer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Direct_RBC::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Direct.RBC)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .fetch.consensus.pb.Direct.RBC.Tag tag = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tag(this),
        _Internal::tag(this).GetCachedSize(), target, stream);
  }

  switch (payload_case()) {
    case kBroadcast: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::broadcast(this),
          _Internal::broadcast(this).GetCachedSize(), target, stream);
      break;
    }
    case kEcho: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::echo(this),
          _Internal::echo(this).GetCachedSize(), target, stream);
      break;
    }
    case kReady: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::ready(this),
          _Internal::ready(this).GetCachedSize(), target, stream);
      break;
    }
    case kRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::request(this),
          _Internal::request(this).GetCachedSize(), target, stream);
      break;
    }
    case kAnswer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::answer(this),
          _Internal::answer(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Direct.RBC)
  return target;
}

size_t Direct_RBC::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Direct.RBC)
  size_t total_size = 0;

  // required .fetch.consensus.pb.Direct.RBC.Tag tag = 1;
  if (_internal_has_tag()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tag_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .fetch.consensus.pb.Direct.RBC.Message broadcast = 2;
    case kBroadcast: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.broadcast_);
      break;
    }
    // .fetch.consensus.pb.Direct.RBC.Hash echo = 3;
    case kEcho: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.echo_);
      break;
    }
    // .fetch.consensus.pb.Direct.RBC.Hash ready = 4;
    case kReady: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.ready_);
      break;
    }
    // .fetch.consensus.pb.Direct.RBC.Hash request = 5;
    case kRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.request_);
      break;
    }
    // .fetch.consensus.pb.Direct.RBC.Message answer = 6;
    case kAnswer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.answer_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Direct_RBC::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Direct_RBC::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Direct_RBC::GetClassData() const { return &_class_data_; }


void Direct_RBC::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Direct_RBC*>(&to_msg);
  auto& from = static_cast<const Direct_RBC&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Direct.RBC)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tag()) {
    _this->_internal_mutable_tag()->::fetch::consensus::pb::Direct_RBC_Tag::MergeFrom(
        from._internal_tag());
  }
  switch (from.payload_case()) {
    case kBroadcast: {
      _this->_internal_mutable_broadcast()->::fetch::consensus::pb::Direct_RBC_Message::MergeFrom(
          from._internal_broadcast());
      break;
    }
    case kEcho: {
      _this->_internal_mutable_echo()->::fetch::consensus::pb::Direct_RBC_Hash::MergeFrom(
          from._internal_echo());
      break;
    }
    case kReady: {
      _this->_internal_mutable_ready()->::fetch::consensus::pb::Direct_RBC_Hash::MergeFrom(
          from._internal_ready());
      break;
    }
    case kRequest: {
      _this->_internal_mutable_request()->::fetch::consensus::pb::Direct_RBC_Hash::MergeFrom(
          from._internal_request());
      break;
    }
    case kAnswer: {
      _this->_internal_mutable_answer()->::fetch::consensus::pb::Direct_RBC_Message::MergeFrom(
          from._internal_answer());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Direct_RBC::CopyFrom(const Direct_RBC& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Direct.RBC)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Direct_RBC::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_tag()) {
    if (!_impl_.tag_->IsInitialized()) return false;
  }
  switch (payload_case()) {
    case kBroadcast: {
      if (_internal_has_broadcast()) {
        if (!_impl_.payload_.broadcast_->IsInitialized()) return false;
      }
      break;
    }
    case kEcho: {
      if (_internal_has_echo()) {
        if (!_impl_.payload_.echo_->IsInitialized()) return false;
      }
      break;
    }
    case kReady: {
      if (_internal_has_ready()) {
        if (!_impl_.payload_.ready_->IsInitialized()) return false;
      }
      break;
    }
    case kRequest: {
      if (_internal_has_request()) {
        if (!_impl_.payload_.request_->IsInitialized()) return false;
      }
      break;
    }
    case kAnswer: {
      if (_internal_has_answer()) {
        if (!_impl_.payload_.answer_->IsInitialized()) return false;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void Direct_RBC::InternalSwap(Direct_RBC* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.tag_, other->_impl_.tag_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Direct_RBC::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[10]);
}

// ===================================================================

class Direct_NoiseMessage::_Internal {
 public:
};

Direct_NoiseMessage::Direct_NoiseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Direct.NoiseMessage)
}
Direct_NoiseMessage::Direct_NoiseMessage(const Direct_NoiseMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Direct_NoiseMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){from._impl_.payload_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Direct.NoiseMessage)
}

inline void Direct_NoiseMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Direct_NoiseMessage::~Direct_NoiseMessage() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Direct.NoiseMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Direct_NoiseMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.payload_.~RepeatedField();
}

void Direct_NoiseMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Direct_NoiseMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Direct.NoiseMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payload_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Direct_NoiseMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 payload = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_payload(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_payload(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Direct_NoiseMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Direct.NoiseMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 payload = 1;
  for (int i = 0, n = this->_internal_payload_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_payload(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Direct.NoiseMessage)
  return target;
}

size_t Direct_NoiseMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Direct.NoiseMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 payload = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.payload_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_payload_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Direct_NoiseMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Direct_NoiseMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Direct_NoiseMessage::GetClassData() const { return &_class_data_; }


void Direct_NoiseMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Direct_NoiseMessage*>(&to_msg);
  auto& from = static_cast<const Direct_NoiseMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Direct.NoiseMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.payload_.MergeFrom(from._impl_.payload_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Direct_NoiseMessage::CopyFrom(const Direct_NoiseMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Direct.NoiseMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Direct_NoiseMessage::IsInitialized() const {
  return true;
}

void Direct_NoiseMessage::InternalSwap(Direct_NoiseMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.payload_.InternalSwap(&other->_impl_.payload_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Direct_NoiseMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[11]);
}

// ===================================================================

class Direct::_Internal {
 public:
  using HasBits = decltype(std::declval<Direct>()._impl_._has_bits_);
  static void set_has_committee_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::fetch::consensus::pb::Direct_RBC& rbc_msg(const Direct* msg);
  static const ::fetch::consensus::pb::Direct_NoiseMessage& handshake(const Direct* msg);
  static const ::fetch::consensus::pb::Direct_NoiseMessage& encrypted_cipher(const Direct* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::fetch::consensus::pb::Direct_RBC&
Direct::_Internal::rbc_msg(const Direct* msg) {
  return *msg->_impl_.payload_.rbc_msg_;
}
const ::fetch::consensus::pb::Direct_NoiseMessage&
Direct::_Internal::handshake(const Direct* msg) {
  return *msg->_impl_.payload_.handshake_;
}
const ::fetch::consensus::pb::Direct_NoiseMessage&
Direct::_Internal::encrypted_cipher(const Direct* msg) {
  return *msg->_impl_.payload_.encrypted_cipher_;
}
void Direct::set_allocated_rbc_msg(::fetch::consensus::pb::Direct_RBC* rbc_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (rbc_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rbc_msg);
    if (message_arena != submessage_arena) {
      rbc_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rbc_msg, submessage_arena);
    }
    set_has_rbc_msg();
    _impl_.payload_.rbc_msg_ = rbc_msg;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.rbc_msg)
}
void Direct::set_allocated_handshake(::fetch::consensus::pb::Direct_NoiseMessage* handshake) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (handshake) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handshake);
    if (message_arena != submessage_arena) {
      handshake = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handshake, submessage_arena);
    }
    set_has_handshake();
    _impl_.payload_.handshake_ = handshake;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.handshake)
}
void Direct::set_allocated_encrypted_cipher(::fetch::consensus::pb::Direct_NoiseMessage* encrypted_cipher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (encrypted_cipher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(encrypted_cipher);
    if (message_arena != submessage_arena) {
      encrypted_cipher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encrypted_cipher, submessage_arena);
    }
    set_has_encrypted_cipher();
    _impl_.payload_.encrypted_cipher_ = encrypted_cipher;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.encrypted_cipher)
}
Direct::Direct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Direct)
}
Direct::Direct(const Direct& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Direct* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.committee_id_){}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.committee_id_ = from._impl_.committee_id_;
  clear_has_payload();
  switch (from.payload_case()) {
    case kRbcMsg: {
      _this->_internal_mutable_rbc_msg()->::fetch::consensus::pb::Direct_RBC::MergeFrom(
          from._internal_rbc_msg());
      break;
    }
    case kHandshake: {
      _this->_internal_mutable_handshake()->::fetch::consensus::pb::Direct_NoiseMessage::MergeFrom(
          from._internal_handshake());
      break;
    }
    case kEncryptedCipher: {
      _this->_internal_mutable_encrypted_cipher()->::fetch::consensus::pb::Direct_NoiseMessage::MergeFrom(
          from._internal_encrypted_cipher());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Direct)
}

inline void Direct::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.committee_id_){0u}
    , decltype(_impl_.payload_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

Direct::~Direct() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Direct)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Direct::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void Direct::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Direct::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:fetch.consensus.pb.Direct)
  switch (payload_case()) {
    case kRbcMsg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.rbc_msg_;
      }
      break;
    }
    case kHandshake: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.handshake_;
      }
      break;
    }
    case kEncryptedCipher: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.encrypted_cipher_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Direct::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Direct)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.committee_id_ = 0u;
  clear_payload();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Direct::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 committee_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_committee_id(&has_bits);
          _impl_.committee_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.RBC rbc_msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rbc_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.NoiseMessage handshake = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_handshake(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Direct.NoiseMessage encrypted_cipher = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_encrypted_cipher(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Direct::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Direct)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 committee_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_committee_id(), target);
  }

  switch (payload_case()) {
    case kRbcMsg: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::rbc_msg(this),
          _Internal::rbc_msg(this).GetCachedSize(), target, stream);
      break;
    }
    case kHandshake: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::handshake(this),
          _Internal::handshake(this).GetCachedSize(), target, stream);
      break;
    }
    case kEncryptedCipher: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::encrypted_cipher(this),
          _Internal::encrypted_cipher(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Direct)
  return target;
}

size_t Direct::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Direct)
  size_t total_size = 0;

  // required uint32 committee_id = 1;
  if (_internal_has_committee_id()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_committee_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .fetch.consensus.pb.Direct.RBC rbc_msg = 2;
    case kRbcMsg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.rbc_msg_);
      break;
    }
    // .fetch.consensus.pb.Direct.NoiseMessage handshake = 3;
    case kHandshake: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.handshake_);
      break;
    }
    // .fetch.consensus.pb.Direct.NoiseMessage encrypted_cipher = 4;
    case kEncryptedCipher: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.encrypted_cipher_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Direct::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Direct::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Direct::GetClassData() const { return &_class_data_; }


void Direct::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Direct*>(&to_msg);
  auto& from = static_cast<const Direct&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Direct)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_committee_id()) {
    _this->_internal_set_committee_id(from._internal_committee_id());
  }
  switch (from.payload_case()) {
    case kRbcMsg: {
      _this->_internal_mutable_rbc_msg()->::fetch::consensus::pb::Direct_RBC::MergeFrom(
          from._internal_rbc_msg());
      break;
    }
    case kHandshake: {
      _this->_internal_mutable_handshake()->::fetch::consensus::pb::Direct_NoiseMessage::MergeFrom(
          from._internal_handshake());
      break;
    }
    case kEncryptedCipher: {
      _this->_internal_mutable_encrypted_cipher()->::fetch::consensus::pb::Direct_NoiseMessage::MergeFrom(
          from._internal_encrypted_cipher());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Direct::CopyFrom(const Direct& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Direct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Direct::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (payload_case()) {
    case kRbcMsg: {
      if (_internal_has_rbc_msg()) {
        if (!_impl_.payload_.rbc_msg_->IsInitialized()) return false;
      }
      break;
    }
    case kHandshake: {
      break;
    }
    case kEncryptedCipher: {
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void Direct::InternalSwap(Direct* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.committee_id_, other->_impl_.committee_id_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Direct::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[12]);
}

// ===================================================================

class Broadcast_Committee::_Internal {
 public:
};

Broadcast_Committee::Broadcast_Committee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Broadcast.Committee)
}
Broadcast_Committee::Broadcast_Committee(const Broadcast_Committee& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Broadcast_Committee* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Broadcast.Committee)
}

inline void Broadcast_Committee::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Broadcast_Committee::~Broadcast_Committee() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Broadcast.Committee)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Broadcast_Committee::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void Broadcast_Committee::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Broadcast_Committee::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Broadcast.Committee)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Broadcast_Committee::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Broadcast.Committee.nodes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Broadcast_Committee::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Broadcast.Committee)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string nodes = 1;
  for (int i = 0, n = this->_internal_nodes_size(); i < n; i++) {
    const auto& s = this->_internal_nodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Broadcast.Committee.nodes");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Broadcast.Committee)
  return target;
}

size_t Broadcast_Committee::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Broadcast.Committee)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string nodes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.nodes_.size());
  for (int i = 0, n = _impl_.nodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.nodes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Broadcast_Committee::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Broadcast_Committee::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Broadcast_Committee::GetClassData() const { return &_class_data_; }


void Broadcast_Committee::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Broadcast_Committee*>(&to_msg);
  auto& from = static_cast<const Broadcast_Committee&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Broadcast.Committee)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Broadcast_Committee::CopyFrom(const Broadcast_Committee& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Broadcast.Committee)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Committee::IsInitialized() const {
  return true;
}

void Broadcast_Committee::InternalSwap(Broadcast_Committee* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Broadcast_Committee::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[13]);
}

// ===================================================================

class Broadcast_Complaints::_Internal {
 public:
};

Broadcast_Complaints::Broadcast_Complaints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Broadcast.Complaints)
}
Broadcast_Complaints::Broadcast_Complaints(const Broadcast_Complaints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Broadcast_Complaints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Broadcast.Complaints)
}

inline void Broadcast_Complaints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Broadcast_Complaints::~Broadcast_Complaints() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Broadcast.Complaints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Broadcast_Complaints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void Broadcast_Complaints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Broadcast_Complaints::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Broadcast.Complaints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Broadcast_Complaints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Broadcast.Complaints.nodes");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Broadcast_Complaints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Broadcast.Complaints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string nodes = 1;
  for (int i = 0, n = this->_internal_nodes_size(); i < n; i++) {
    const auto& s = this->_internal_nodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Broadcast.Complaints.nodes");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Broadcast.Complaints)
  return target;
}

size_t Broadcast_Complaints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Broadcast.Complaints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string nodes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.nodes_.size());
  for (int i = 0, n = _impl_.nodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.nodes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Broadcast_Complaints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Broadcast_Complaints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Broadcast_Complaints::GetClassData() const { return &_class_data_; }


void Broadcast_Complaints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Broadcast_Complaints*>(&to_msg);
  auto& from = static_cast<const Broadcast_Complaints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Broadcast.Complaints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Broadcast_Complaints::CopyFrom(const Broadcast_Complaints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Broadcast.Complaints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Complaints::IsInitialized() const {
  return true;
}

void Broadcast_Complaints::InternalSwap(Broadcast_Complaints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Broadcast_Complaints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[14]);
}

// ===================================================================

class Broadcast_Shares::_Internal {
 public:
  using HasBits = decltype(std::declval<Broadcast_Shares>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Broadcast_Shares::Broadcast_Shares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Broadcast.Shares)
}
Broadcast_Shares::Broadcast_Shares(const Broadcast_Shares& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Broadcast_Shares* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_){from._impl_.first_}
    , decltype(_impl_.second_){from._impl_.second_}
    , decltype(_impl_.reporter_){from._impl_.reporter_}
    , decltype(_impl_.phase_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.phase_ = from._impl_.phase_;
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Broadcast.Shares)
}

inline void Broadcast_Shares::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_){arena}
    , decltype(_impl_.second_){arena}
    , decltype(_impl_.reporter_){arena}
    , decltype(_impl_.phase_){uint64_t{0u}}
  };
}

Broadcast_Shares::~Broadcast_Shares() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Broadcast.Shares)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Broadcast_Shares::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.first_.~RepeatedPtrField();
  _impl_.second_.~RepeatedPtrField();
  _impl_.reporter_.~RepeatedPtrField();
}

void Broadcast_Shares::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Broadcast_Shares::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Broadcast.Shares)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.first_.Clear();
  _impl_.second_.Clear();
  _impl_.reporter_.Clear();
  _impl_.phase_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Broadcast_Shares::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 phase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_phase(&has_bits);
          _impl_.phase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string first = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_first();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Broadcast.Shares.first");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string second = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_second();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Broadcast.Shares.second");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string reporter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_reporter();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Broadcast.Shares.reporter");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Broadcast_Shares::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Broadcast.Shares)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 phase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_phase(), target);
  }

  // repeated string first = 2;
  for (int i = 0, n = this->_internal_first_size(); i < n; i++) {
    const auto& s = this->_internal_first(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Broadcast.Shares.first");
    target = stream->WriteString(2, s, target);
  }

  // repeated string second = 3;
  for (int i = 0, n = this->_internal_second_size(); i < n; i++) {
    const auto& s = this->_internal_second(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Broadcast.Shares.second");
    target = stream->WriteString(3, s, target);
  }

  // repeated string reporter = 4;
  for (int i = 0, n = this->_internal_reporter_size(); i < n; i++) {
    const auto& s = this->_internal_reporter(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Broadcast.Shares.reporter");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Broadcast.Shares)
  return target;
}

size_t Broadcast_Shares::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Broadcast.Shares)
  size_t total_size = 0;

  // required uint64 phase = 1;
  if (_internal_has_phase()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_phase());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string first = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.first_.size());
  for (int i = 0, n = _impl_.first_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.first_.Get(i));
  }

  // repeated string second = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.second_.size());
  for (int i = 0, n = _impl_.second_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.second_.Get(i));
  }

  // repeated string reporter = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.reporter_.size());
  for (int i = 0, n = _impl_.reporter_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.reporter_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Broadcast_Shares::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Broadcast_Shares::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Broadcast_Shares::GetClassData() const { return &_class_data_; }


void Broadcast_Shares::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Broadcast_Shares*>(&to_msg);
  auto& from = static_cast<const Broadcast_Shares&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Broadcast.Shares)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.first_.MergeFrom(from._impl_.first_);
  _this->_impl_.second_.MergeFrom(from._impl_.second_);
  _this->_impl_.reporter_.MergeFrom(from._impl_.reporter_);
  if (from._internal_has_phase()) {
    _this->_internal_set_phase(from._internal_phase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Broadcast_Shares::CopyFrom(const Broadcast_Shares& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Broadcast.Shares)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Shares::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Broadcast_Shares::InternalSwap(Broadcast_Shares* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.first_.InternalSwap(&other->_impl_.first_);
  _impl_.second_.InternalSwap(&other->_impl_.second_);
  _impl_.reporter_.InternalSwap(&other->_impl_.reporter_);
  swap(_impl_.phase_, other->_impl_.phase_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Broadcast_Shares::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[15]);
}

// ===================================================================

class Broadcast_Coefficients::_Internal {
 public:
  using HasBits = decltype(std::declval<Broadcast_Coefficients>()._impl_._has_bits_);
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Broadcast_Coefficients::Broadcast_Coefficients(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Broadcast.Coefficients)
}
Broadcast_Coefficients::Broadcast_Coefficients(const Broadcast_Coefficients& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Broadcast_Coefficients* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coefficients_){from._impl_.coefficients_}
    , decltype(_impl_.phase_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.phase_ = from._impl_.phase_;
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Broadcast.Coefficients)
}

inline void Broadcast_Coefficients::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coefficients_){arena}
    , decltype(_impl_.phase_){uint64_t{0u}}
  };
}

Broadcast_Coefficients::~Broadcast_Coefficients() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Broadcast.Coefficients)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Broadcast_Coefficients::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.coefficients_.~RepeatedPtrField();
}

void Broadcast_Coefficients::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Broadcast_Coefficients::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Broadcast.Coefficients)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.coefficients_.Clear();
  _impl_.phase_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Broadcast_Coefficients::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 phase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_phase(&has_bits);
          _impl_.phase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string coefficients = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_coefficients();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "fetch.consensus.pb.Broadcast.Coefficients.coefficients");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Broadcast_Coefficients::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Broadcast.Coefficients)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 phase = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_phase(), target);
  }

  // repeated string coefficients = 2;
  for (int i = 0, n = this->_internal_coefficients_size(); i < n; i++) {
    const auto& s = this->_internal_coefficients(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fetch.consensus.pb.Broadcast.Coefficients.coefficients");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Broadcast.Coefficients)
  return target;
}

size_t Broadcast_Coefficients::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Broadcast.Coefficients)
  size_t total_size = 0;

  // required uint64 phase = 1;
  if (_internal_has_phase()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_phase());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string coefficients = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.coefficients_.size());
  for (int i = 0, n = _impl_.coefficients_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.coefficients_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Broadcast_Coefficients::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Broadcast_Coefficients::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Broadcast_Coefficients::GetClassData() const { return &_class_data_; }


void Broadcast_Coefficients::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Broadcast_Coefficients*>(&to_msg);
  auto& from = static_cast<const Broadcast_Coefficients&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Broadcast.Coefficients)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.coefficients_.MergeFrom(from._impl_.coefficients_);
  if (from._internal_has_phase()) {
    _this->_internal_set_phase(from._internal_phase());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Broadcast_Coefficients::CopyFrom(const Broadcast_Coefficients& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Broadcast.Coefficients)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast_Coefficients::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Broadcast_Coefficients::InternalSwap(Broadcast_Coefficients* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.coefficients_.InternalSwap(&other->_impl_.coefficients_);
  swap(_impl_.phase_, other->_impl_.phase_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Broadcast_Coefficients::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[16]);
}

// ===================================================================

class Broadcast::_Internal {
 public:
  static const ::fetch::consensus::pb::Broadcast_Complaints& complaints(const Broadcast* msg);
  static const ::fetch::consensus::pb::Broadcast_Shares& shares(const Broadcast* msg);
  static const ::fetch::consensus::pb::Broadcast_Coefficients& coefficients(const Broadcast* msg);
  static const ::fetch::consensus::pb::Broadcast_Committee& committee(const Broadcast* msg);
};

const ::fetch::consensus::pb::Broadcast_Complaints&
Broadcast::_Internal::complaints(const Broadcast* msg) {
  return *msg->_impl_.payload_.complaints_;
}
const ::fetch::consensus::pb::Broadcast_Shares&
Broadcast::_Internal::shares(const Broadcast* msg) {
  return *msg->_impl_.payload_.shares_;
}
const ::fetch::consensus::pb::Broadcast_Coefficients&
Broadcast::_Internal::coefficients(const Broadcast* msg) {
  return *msg->_impl_.payload_.coefficients_;
}
const ::fetch::consensus::pb::Broadcast_Committee&
Broadcast::_Internal::committee(const Broadcast* msg) {
  return *msg->_impl_.payload_.committee_;
}
void Broadcast::set_allocated_complaints(::fetch::consensus::pb::Broadcast_Complaints* complaints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (complaints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(complaints);
    if (message_arena != submessage_arena) {
      complaints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, complaints, submessage_arena);
    }
    set_has_complaints();
    _impl_.payload_.complaints_ = complaints;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Broadcast.complaints)
}
void Broadcast::set_allocated_shares(::fetch::consensus::pb::Broadcast_Shares* shares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (shares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shares);
    if (message_arena != submessage_arena) {
      shares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shares, submessage_arena);
    }
    set_has_shares();
    _impl_.payload_.shares_ = shares;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Broadcast.shares)
}
void Broadcast::set_allocated_coefficients(::fetch::consensus::pb::Broadcast_Coefficients* coefficients) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (coefficients) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coefficients);
    if (message_arena != submessage_arena) {
      coefficients = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coefficients, submessage_arena);
    }
    set_has_coefficients();
    _impl_.payload_.coefficients_ = coefficients;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Broadcast.coefficients)
}
void Broadcast::set_allocated_committee(::fetch::consensus::pb::Broadcast_Committee* committee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_payload();
  if (committee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(committee);
    if (message_arena != submessage_arena) {
      committee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, committee, submessage_arena);
    }
    set_has_committee();
    _impl_.payload_.committee_ = committee;
  }
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Broadcast.committee)
}
Broadcast::Broadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:fetch.consensus.pb.Broadcast)
}
Broadcast::Broadcast(const Broadcast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Broadcast* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_payload();
  switch (from.payload_case()) {
    case kComplaints: {
      _this->_internal_mutable_complaints()->::fetch::consensus::pb::Broadcast_Complaints::MergeFrom(
          from._internal_complaints());
      break;
    }
    case kShares: {
      _this->_internal_mutable_shares()->::fetch::consensus::pb::Broadcast_Shares::MergeFrom(
          from._internal_shares());
      break;
    }
    case kCoefficients: {
      _this->_internal_mutable_coefficients()->::fetch::consensus::pb::Broadcast_Coefficients::MergeFrom(
          from._internal_coefficients());
      break;
    }
    case kCommittee: {
      _this->_internal_mutable_committee()->::fetch::consensus::pb::Broadcast_Committee::MergeFrom(
          from._internal_committee());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:fetch.consensus.pb.Broadcast)
}

inline void Broadcast::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.payload_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_payload();
}

Broadcast::~Broadcast() {
  // @@protoc_insertion_point(destructor:fetch.consensus.pb.Broadcast)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Broadcast::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_payload()) {
    clear_payload();
  }
}

void Broadcast::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Broadcast::clear_payload() {
// @@protoc_insertion_point(one_of_clear_start:fetch.consensus.pb.Broadcast)
  switch (payload_case()) {
    case kComplaints: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.complaints_;
      }
      break;
    }
    case kShares: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.shares_;
      }
      break;
    }
    case kCoefficients: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.coefficients_;
      }
      break;
    }
    case kCommittee: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.payload_.committee_;
      }
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}


void Broadcast::Clear() {
// @@protoc_insertion_point(message_clear_start:fetch.consensus.pb.Broadcast)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Broadcast::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .fetch.consensus.pb.Broadcast.Complaints complaints = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_complaints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Broadcast.Shares shares = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_shares(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Broadcast.Coefficients coefficients = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_coefficients(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .fetch.consensus.pb.Broadcast.Committee committee = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_committee(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Broadcast::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fetch.consensus.pb.Broadcast)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (payload_case()) {
    case kComplaints: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::complaints(this),
          _Internal::complaints(this).GetCachedSize(), target, stream);
      break;
    }
    case kShares: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::shares(this),
          _Internal::shares(this).GetCachedSize(), target, stream);
      break;
    }
    case kCoefficients: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::coefficients(this),
          _Internal::coefficients(this).GetCachedSize(), target, stream);
      break;
    }
    case kCommittee: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::committee(this),
          _Internal::committee(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fetch.consensus.pb.Broadcast)
  return target;
}

size_t Broadcast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fetch.consensus.pb.Broadcast)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (payload_case()) {
    // .fetch.consensus.pb.Broadcast.Complaints complaints = 1;
    case kComplaints: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.complaints_);
      break;
    }
    // .fetch.consensus.pb.Broadcast.Shares shares = 2;
    case kShares: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.shares_);
      break;
    }
    // .fetch.consensus.pb.Broadcast.Coefficients coefficients = 3;
    case kCoefficients: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.coefficients_);
      break;
    }
    // .fetch.consensus.pb.Broadcast.Committee committee = 4;
    case kCommittee: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.payload_.committee_);
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Broadcast::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Broadcast::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Broadcast::GetClassData() const { return &_class_data_; }


void Broadcast::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Broadcast*>(&to_msg);
  auto& from = static_cast<const Broadcast&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:fetch.consensus.pb.Broadcast)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.payload_case()) {
    case kComplaints: {
      _this->_internal_mutable_complaints()->::fetch::consensus::pb::Broadcast_Complaints::MergeFrom(
          from._internal_complaints());
      break;
    }
    case kShares: {
      _this->_internal_mutable_shares()->::fetch::consensus::pb::Broadcast_Shares::MergeFrom(
          from._internal_shares());
      break;
    }
    case kCoefficients: {
      _this->_internal_mutable_coefficients()->::fetch::consensus::pb::Broadcast_Coefficients::MergeFrom(
          from._internal_coefficients());
      break;
    }
    case kCommittee: {
      _this->_internal_mutable_committee()->::fetch::consensus::pb::Broadcast_Committee::MergeFrom(
          from._internal_committee());
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Broadcast::CopyFrom(const Broadcast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fetch.consensus.pb.Broadcast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Broadcast::IsInitialized() const {
  switch (payload_case()) {
    case kComplaints: {
      break;
    }
    case kShares: {
      if (_internal_has_shares()) {
        if (!_impl_.payload_.shares_->IsInitialized()) return false;
      }
      break;
    }
    case kCoefficients: {
      if (_internal_has_coefficients()) {
        if (!_impl_.payload_.coefficients_->IsInitialized()) return false;
      }
      break;
    }
    case kCommittee: {
      break;
    }
    case PAYLOAD_NOT_SET: {
      break;
    }
  }
  return true;
}

void Broadcast::InternalSwap(Broadcast* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_, other->_impl_.payload_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Broadcast::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_consensus_2eproto_getter, &descriptor_table_consensus_2eproto_once,
      file_level_metadata_consensus_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace consensus
}  // namespace fetch
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Neighbour*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Neighbour >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Neighbour >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::PrivateShares*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::PrivateShares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::PrivateShares >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Message_Join*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Message_Join >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Message_Join >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Message_Gossip*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Message_Gossip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Message_Gossip >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Message*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Message >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Gossip_SignatureShare*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Gossip_SignatureShare >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Gossip_SignatureShare >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Gossip*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Gossip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Gossip >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Direct_RBC_Tag*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Tag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Direct_RBC_Tag >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Direct_RBC_Message*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Message >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Direct_RBC_Message >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Direct_RBC_Hash*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Hash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Direct_RBC_Hash >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Direct_RBC*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Direct_RBC >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Direct_NoiseMessage*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Direct_NoiseMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Direct_NoiseMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Direct*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Direct >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Direct >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Broadcast_Committee*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Committee >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Broadcast_Committee >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Broadcast_Complaints*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Complaints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Broadcast_Complaints >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Broadcast_Shares*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Shares >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Broadcast_Shares >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Broadcast_Coefficients*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Coefficients >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Broadcast_Coefficients >(arena);
}
template<> PROTOBUF_NOINLINE ::fetch::consensus::pb::Broadcast*
Arena::CreateMaybeMessage< ::fetch::consensus::pb::Broadcast >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fetch::consensus::pb::Broadcast >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
