// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: consensus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_consensus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_consensus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_consensus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_consensus_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_consensus_2eproto;
namespace fetch {
namespace consensus {
namespace pb {
class Broadcast;
struct BroadcastDefaultTypeInternal;
extern BroadcastDefaultTypeInternal _Broadcast_default_instance_;
class Broadcast_Coefficients;
struct Broadcast_CoefficientsDefaultTypeInternal;
extern Broadcast_CoefficientsDefaultTypeInternal _Broadcast_Coefficients_default_instance_;
class Broadcast_Committee;
struct Broadcast_CommitteeDefaultTypeInternal;
extern Broadcast_CommitteeDefaultTypeInternal _Broadcast_Committee_default_instance_;
class Broadcast_Complaints;
struct Broadcast_ComplaintsDefaultTypeInternal;
extern Broadcast_ComplaintsDefaultTypeInternal _Broadcast_Complaints_default_instance_;
class Broadcast_Shares;
struct Broadcast_SharesDefaultTypeInternal;
extern Broadcast_SharesDefaultTypeInternal _Broadcast_Shares_default_instance_;
class Direct;
struct DirectDefaultTypeInternal;
extern DirectDefaultTypeInternal _Direct_default_instance_;
class Direct_NoiseMessage;
struct Direct_NoiseMessageDefaultTypeInternal;
extern Direct_NoiseMessageDefaultTypeInternal _Direct_NoiseMessage_default_instance_;
class Direct_RBC;
struct Direct_RBCDefaultTypeInternal;
extern Direct_RBCDefaultTypeInternal _Direct_RBC_default_instance_;
class Direct_RBC_Hash;
struct Direct_RBC_HashDefaultTypeInternal;
extern Direct_RBC_HashDefaultTypeInternal _Direct_RBC_Hash_default_instance_;
class Direct_RBC_Message;
struct Direct_RBC_MessageDefaultTypeInternal;
extern Direct_RBC_MessageDefaultTypeInternal _Direct_RBC_Message_default_instance_;
class Direct_RBC_Tag;
struct Direct_RBC_TagDefaultTypeInternal;
extern Direct_RBC_TagDefaultTypeInternal _Direct_RBC_Tag_default_instance_;
class Gossip;
struct GossipDefaultTypeInternal;
extern GossipDefaultTypeInternal _Gossip_default_instance_;
class Gossip_SignatureShare;
struct Gossip_SignatureShareDefaultTypeInternal;
extern Gossip_SignatureShareDefaultTypeInternal _Gossip_SignatureShare_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Message_Gossip;
struct Message_GossipDefaultTypeInternal;
extern Message_GossipDefaultTypeInternal _Message_Gossip_default_instance_;
class Message_Join;
struct Message_JoinDefaultTypeInternal;
extern Message_JoinDefaultTypeInternal _Message_Join_default_instance_;
class Neighbour;
struct NeighbourDefaultTypeInternal;
extern NeighbourDefaultTypeInternal _Neighbour_default_instance_;
class PrivateShares;
struct PrivateSharesDefaultTypeInternal;
extern PrivateSharesDefaultTypeInternal _PrivateShares_default_instance_;
}  // namespace pb
}  // namespace consensus
}  // namespace fetch
PROTOBUF_NAMESPACE_OPEN
template<> ::fetch::consensus::pb::Broadcast* Arena::CreateMaybeMessage<::fetch::consensus::pb::Broadcast>(Arena*);
template<> ::fetch::consensus::pb::Broadcast_Coefficients* Arena::CreateMaybeMessage<::fetch::consensus::pb::Broadcast_Coefficients>(Arena*);
template<> ::fetch::consensus::pb::Broadcast_Committee* Arena::CreateMaybeMessage<::fetch::consensus::pb::Broadcast_Committee>(Arena*);
template<> ::fetch::consensus::pb::Broadcast_Complaints* Arena::CreateMaybeMessage<::fetch::consensus::pb::Broadcast_Complaints>(Arena*);
template<> ::fetch::consensus::pb::Broadcast_Shares* Arena::CreateMaybeMessage<::fetch::consensus::pb::Broadcast_Shares>(Arena*);
template<> ::fetch::consensus::pb::Direct* Arena::CreateMaybeMessage<::fetch::consensus::pb::Direct>(Arena*);
template<> ::fetch::consensus::pb::Direct_NoiseMessage* Arena::CreateMaybeMessage<::fetch::consensus::pb::Direct_NoiseMessage>(Arena*);
template<> ::fetch::consensus::pb::Direct_RBC* Arena::CreateMaybeMessage<::fetch::consensus::pb::Direct_RBC>(Arena*);
template<> ::fetch::consensus::pb::Direct_RBC_Hash* Arena::CreateMaybeMessage<::fetch::consensus::pb::Direct_RBC_Hash>(Arena*);
template<> ::fetch::consensus::pb::Direct_RBC_Message* Arena::CreateMaybeMessage<::fetch::consensus::pb::Direct_RBC_Message>(Arena*);
template<> ::fetch::consensus::pb::Direct_RBC_Tag* Arena::CreateMaybeMessage<::fetch::consensus::pb::Direct_RBC_Tag>(Arena*);
template<> ::fetch::consensus::pb::Gossip* Arena::CreateMaybeMessage<::fetch::consensus::pb::Gossip>(Arena*);
template<> ::fetch::consensus::pb::Gossip_SignatureShare* Arena::CreateMaybeMessage<::fetch::consensus::pb::Gossip_SignatureShare>(Arena*);
template<> ::fetch::consensus::pb::Message* Arena::CreateMaybeMessage<::fetch::consensus::pb::Message>(Arena*);
template<> ::fetch::consensus::pb::Message_Gossip* Arena::CreateMaybeMessage<::fetch::consensus::pb::Message_Gossip>(Arena*);
template<> ::fetch::consensus::pb::Message_Join* Arena::CreateMaybeMessage<::fetch::consensus::pb::Message_Join>(Arena*);
template<> ::fetch::consensus::pb::Neighbour* Arena::CreateMaybeMessage<::fetch::consensus::pb::Neighbour>(Arena*);
template<> ::fetch::consensus::pb::PrivateShares* Arena::CreateMaybeMessage<::fetch::consensus::pb::PrivateShares>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fetch {
namespace consensus {
namespace pb {

// ===================================================================

class Neighbour final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Neighbour) */ {
 public:
  inline Neighbour() : Neighbour(nullptr) {}
  ~Neighbour() override;
  explicit PROTOBUF_CONSTEXPR Neighbour(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Neighbour(const Neighbour& from);
  Neighbour(Neighbour&& from) noexcept
    : Neighbour() {
    *this = ::std::move(from);
  }

  inline Neighbour& operator=(const Neighbour& from) {
    CopyFrom(from);
    return *this;
  }
  inline Neighbour& operator=(Neighbour&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Neighbour& default_instance() {
    return *internal_default_instance();
  }
  static inline const Neighbour* internal_default_instance() {
    return reinterpret_cast<const Neighbour*>(
               &_Neighbour_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Neighbour& a, Neighbour& b) {
    a.Swap(&b);
  }
  inline void Swap(Neighbour* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Neighbour* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Neighbour* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Neighbour>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Neighbour& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Neighbour& from) {
    Neighbour::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Neighbour* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Neighbour";
  }
  protected:
  explicit Neighbour(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDhPublicKeyFieldNumber = 4,
    kKeySignatureFieldNumber = 5,
    kIdFieldNumber = 1,
    kPublicKeyFieldNumber = 3,
    kPortFieldNumber = 2,
  };
  // repeated uint32 dh_public_key = 4;
  int dh_public_key_size() const;
  private:
  int _internal_dh_public_key_size() const;
  public:
  void clear_dh_public_key();
  private:
  uint32_t _internal_dh_public_key(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_dh_public_key() const;
  void _internal_add_dh_public_key(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_dh_public_key();
  public:
  uint32_t dh_public_key(int index) const;
  void set_dh_public_key(int index, uint32_t value);
  void add_dh_public_key(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      dh_public_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_dh_public_key();

  // repeated uint32 key_signature = 5;
  int key_signature_size() const;
  private:
  int _internal_key_signature_size() const;
  public:
  void clear_key_signature();
  private:
  uint32_t _internal_key_signature(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_key_signature() const;
  void _internal_add_key_signature(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_key_signature();
  public:
  uint32_t key_signature(int index) const;
  void set_key_signature(int index, uint32_t value);
  void add_key_signature(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      key_signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_key_signature();

  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // required string public_key = 3;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // required uint32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Neighbour)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > dh_public_key_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > key_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
    uint32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class PrivateShares final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.PrivateShares) */ {
 public:
  inline PrivateShares() : PrivateShares(nullptr) {}
  ~PrivateShares() override;
  explicit PROTOBUF_CONSTEXPR PrivateShares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivateShares(const PrivateShares& from);
  PrivateShares(PrivateShares&& from) noexcept
    : PrivateShares() {
    *this = ::std::move(from);
  }

  inline PrivateShares& operator=(const PrivateShares& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivateShares& operator=(PrivateShares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivateShares& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivateShares* internal_default_instance() {
    return reinterpret_cast<const PrivateShares*>(
               &_PrivateShares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PrivateShares& a, PrivateShares& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivateShares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivateShares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivateShares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivateShares>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivateShares& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivateShares& from) {
    PrivateShares::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivateShares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.PrivateShares";
  }
  protected:
  explicit PrivateShares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required string first = 1;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  const std::string& first() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first();
  PROTOBUF_NODISCARD std::string* release_first();
  void set_allocated_first(std::string* first);
  private:
  const std::string& _internal_first() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first(const std::string& value);
  std::string* _internal_mutable_first();
  public:

  // required string second = 2;
  bool has_second() const;
  private:
  bool _internal_has_second() const;
  public:
  void clear_second();
  const std::string& second() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_second(ArgT0&& arg0, ArgT... args);
  std::string* mutable_second();
  PROTOBUF_NODISCARD std::string* release_second();
  void set_allocated_second(std::string* second);
  private:
  const std::string& _internal_second() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_second(const std::string& value);
  std::string* _internal_mutable_second();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.PrivateShares)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr second_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Message_Join final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Message.Join) */ {
 public:
  inline Message_Join() : Message_Join(nullptr) {}
  ~Message_Join() override;
  explicit PROTOBUF_CONSTEXPR Message_Join(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message_Join(const Message_Join& from);
  Message_Join(Message_Join&& from) noexcept
    : Message_Join() {
    *this = ::std::move(from);
  }

  inline Message_Join& operator=(const Message_Join& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message_Join& operator=(Message_Join&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message_Join& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message_Join* internal_default_instance() {
    return reinterpret_cast<const Message_Join*>(
               &_Message_Join_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Message_Join& a, Message_Join& b) {
    a.Swap(&b);
  }
  inline void Swap(Message_Join* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message_Join* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message_Join* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message_Join>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message_Join& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message_Join& from) {
    Message_Join::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message_Join* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Message.Join";
  }
  protected:
  explicit Message_Join(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated string nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  const std::string& nodes(int index) const;
  std::string* mutable_nodes(int index);
  void set_nodes(int index, const std::string& value);
  void set_nodes(int index, std::string&& value);
  void set_nodes(int index, const char* value);
  void set_nodes(int index, const char* value, size_t size);
  std::string* add_nodes();
  void add_nodes(const std::string& value);
  void add_nodes(std::string&& value);
  void add_nodes(const char* value);
  void add_nodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nodes();
  private:
  const std::string& _internal_nodes(int index) const;
  std::string* _internal_add_nodes();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Message.Join)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Message_Gossip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Message.Gossip) */ {
 public:
  inline Message_Gossip() : Message_Gossip(nullptr) {}
  ~Message_Gossip() override;
  explicit PROTOBUF_CONSTEXPR Message_Gossip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message_Gossip(const Message_Gossip& from);
  Message_Gossip(Message_Gossip&& from) noexcept
    : Message_Gossip() {
    *this = ::std::move(from);
  }

  inline Message_Gossip& operator=(const Message_Gossip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message_Gossip& operator=(Message_Gossip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message_Gossip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message_Gossip* internal_default_instance() {
    return reinterpret_cast<const Message_Gossip*>(
               &_Message_Gossip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Message_Gossip& a, Message_Gossip& b) {
    a.Swap(&b);
  }
  inline void Swap(Message_Gossip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message_Gossip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message_Gossip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message_Gossip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message_Gossip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message_Gossip& from) {
    Message_Gossip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message_Gossip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Message.Gossip";
  }
  protected:
  explicit Message_Gossip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 5,
    kMsgFieldNumber = 3,
    kOriginFieldNumber = 4,
    kStepFieldNumber = 1,
    kGossipFieldNumber = 2,
  };
  // repeated uint32 signature = 5;
  int signature_size() const;
  private:
  int _internal_signature_size() const;
  public:
  void clear_signature();
  private:
  uint32_t _internal_signature(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_signature() const;
  void _internal_add_signature(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_signature();
  public:
  uint32_t signature(int index) const;
  void set_signature(int index, uint32_t value);
  void add_signature(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_signature();

  // required bytes msg = 3;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // required string origin = 4;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const std::string& origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_origin();
  PROTOBUF_NODISCARD std::string* release_origin();
  void set_allocated_origin(std::string* origin);
  private:
  const std::string& _internal_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin(const std::string& value);
  std::string* _internal_mutable_origin();
  public:

  // required uint64 step = 1;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  uint64_t step() const;
  void set_step(uint64_t value);
  private:
  uint64_t _internal_step() const;
  void _internal_set_step(uint64_t value);
  public:

  // required bool gossip = 2;
  bool has_gossip() const;
  private:
  bool _internal_has_gossip() const;
  public:
  void clear_gossip();
  bool gossip() const;
  void set_gossip(bool value);
  private:
  bool _internal_gossip() const;
  void _internal_set_gossip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Message.Gossip)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_;
    uint64_t step_;
    bool gossip_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kJoin = 1,
    kGossip = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_Join Join;
  typedef Message_Gossip Gossip;

  // accessors -------------------------------------------------------

  enum : int {
    kJoinFieldNumber = 1,
    kGossipFieldNumber = 2,
  };
  // .fetch.consensus.pb.Message.Join join = 1;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::fetch::consensus::pb::Message_Join& join() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Message_Join* release_join();
  ::fetch::consensus::pb::Message_Join* mutable_join();
  void set_allocated_join(::fetch::consensus::pb::Message_Join* join);
  private:
  const ::fetch::consensus::pb::Message_Join& _internal_join() const;
  ::fetch::consensus::pb::Message_Join* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::fetch::consensus::pb::Message_Join* join);
  ::fetch::consensus::pb::Message_Join* unsafe_arena_release_join();

  // .fetch.consensus.pb.Message.Gossip gossip = 2;
  bool has_gossip() const;
  private:
  bool _internal_has_gossip() const;
  public:
  void clear_gossip();
  const ::fetch::consensus::pb::Message_Gossip& gossip() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Message_Gossip* release_gossip();
  ::fetch::consensus::pb::Message_Gossip* mutable_gossip();
  void set_allocated_gossip(::fetch::consensus::pb::Message_Gossip* gossip);
  private:
  const ::fetch::consensus::pb::Message_Gossip& _internal_gossip() const;
  ::fetch::consensus::pb::Message_Gossip* _internal_mutable_gossip();
  public:
  void unsafe_arena_set_allocated_gossip(
      ::fetch::consensus::pb::Message_Gossip* gossip);
  ::fetch::consensus::pb::Message_Gossip* unsafe_arena_release_gossip();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Message)
 private:
  class _Internal;
  void set_has_join();
  void set_has_gossip();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::fetch::consensus::pb::Message_Join* join_;
      ::fetch::consensus::pb::Message_Gossip* gossip_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Gossip_SignatureShare final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Gossip.SignatureShare) */ {
 public:
  inline Gossip_SignatureShare() : Gossip_SignatureShare(nullptr) {}
  ~Gossip_SignatureShare() override;
  explicit PROTOBUF_CONSTEXPR Gossip_SignatureShare(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gossip_SignatureShare(const Gossip_SignatureShare& from);
  Gossip_SignatureShare(Gossip_SignatureShare&& from) noexcept
    : Gossip_SignatureShare() {
    *this = ::std::move(from);
  }

  inline Gossip_SignatureShare& operator=(const Gossip_SignatureShare& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gossip_SignatureShare& operator=(Gossip_SignatureShare&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gossip_SignatureShare& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gossip_SignatureShare* internal_default_instance() {
    return reinterpret_cast<const Gossip_SignatureShare*>(
               &_Gossip_SignatureShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Gossip_SignatureShare& a, Gossip_SignatureShare& b) {
    a.Swap(&b);
  }
  inline void Swap(Gossip_SignatureShare* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gossip_SignatureShare* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gossip_SignatureShare* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gossip_SignatureShare>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gossip_SignatureShare& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gossip_SignatureShare& from) {
    Gossip_SignatureShare::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gossip_SignatureShare* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Gossip.SignatureShare";
  }
  protected:
  explicit Gossip_SignatureShare(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kShareSigFieldNumber = 2,
    kSharePiFieldNumber = 3,
    kSharePi2FieldNumber = 4,
  };
  // required string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required string share_sig = 2;
  bool has_share_sig() const;
  private:
  bool _internal_has_share_sig() const;
  public:
  void clear_share_sig();
  const std::string& share_sig() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_share_sig(ArgT0&& arg0, ArgT... args);
  std::string* mutable_share_sig();
  PROTOBUF_NODISCARD std::string* release_share_sig();
  void set_allocated_share_sig(std::string* share_sig);
  private:
  const std::string& _internal_share_sig() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_share_sig(const std::string& value);
  std::string* _internal_mutable_share_sig();
  public:

  // optional string share_pi = 3;
  bool has_share_pi() const;
  private:
  bool _internal_has_share_pi() const;
  public:
  void clear_share_pi();
  const std::string& share_pi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_share_pi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_share_pi();
  PROTOBUF_NODISCARD std::string* release_share_pi();
  void set_allocated_share_pi(std::string* share_pi);
  private:
  const std::string& _internal_share_pi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_share_pi(const std::string& value);
  std::string* _internal_mutable_share_pi();
  public:

  // optional string share_pi2 = 4;
  bool has_share_pi2() const;
  private:
  bool _internal_has_share_pi2() const;
  public:
  void clear_share_pi2();
  const std::string& share_pi2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_share_pi2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_share_pi2();
  PROTOBUF_NODISCARD std::string* release_share_pi2();
  void set_allocated_share_pi2(std::string* share_pi2);
  private:
  const std::string& _internal_share_pi2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_share_pi2(const std::string& value);
  std::string* _internal_mutable_share_pi2();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Gossip.SignatureShare)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_sig_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_pi_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_pi2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Gossip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Gossip) */ {
 public:
  inline Gossip() : Gossip(nullptr) {}
  ~Gossip() override;
  explicit PROTOBUF_CONSTEXPR Gossip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gossip(const Gossip& from);
  Gossip(Gossip&& from) noexcept
    : Gossip() {
    *this = ::std::move(from);
  }

  inline Gossip& operator=(const Gossip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gossip& operator=(Gossip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gossip& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSigShare = 1,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Gossip* internal_default_instance() {
    return reinterpret_cast<const Gossip*>(
               &_Gossip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Gossip& a, Gossip& b) {
    a.Swap(&b);
  }
  inline void Swap(Gossip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gossip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gossip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gossip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gossip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gossip& from) {
    Gossip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gossip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Gossip";
  }
  protected:
  explicit Gossip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Gossip_SignatureShare SignatureShare;

  // accessors -------------------------------------------------------

  enum : int {
    kSigShareFieldNumber = 1,
  };
  // .fetch.consensus.pb.Gossip.SignatureShare sig_share = 1;
  bool has_sig_share() const;
  private:
  bool _internal_has_sig_share() const;
  public:
  void clear_sig_share();
  const ::fetch::consensus::pb::Gossip_SignatureShare& sig_share() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Gossip_SignatureShare* release_sig_share();
  ::fetch::consensus::pb::Gossip_SignatureShare* mutable_sig_share();
  void set_allocated_sig_share(::fetch::consensus::pb::Gossip_SignatureShare* sig_share);
  private:
  const ::fetch::consensus::pb::Gossip_SignatureShare& _internal_sig_share() const;
  ::fetch::consensus::pb::Gossip_SignatureShare* _internal_mutable_sig_share();
  public:
  void unsafe_arena_set_allocated_sig_share(
      ::fetch::consensus::pb::Gossip_SignatureShare* sig_share);
  ::fetch::consensus::pb::Gossip_SignatureShare* unsafe_arena_release_sig_share();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Gossip)
 private:
  class _Internal;
  void set_has_sig_share();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::fetch::consensus::pb::Gossip_SignatureShare* sig_share_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Direct_RBC_Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Direct.RBC.Tag) */ {
 public:
  inline Direct_RBC_Tag() : Direct_RBC_Tag(nullptr) {}
  ~Direct_RBC_Tag() override;
  explicit PROTOBUF_CONSTEXPR Direct_RBC_Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Direct_RBC_Tag(const Direct_RBC_Tag& from);
  Direct_RBC_Tag(Direct_RBC_Tag&& from) noexcept
    : Direct_RBC_Tag() {
    *this = ::std::move(from);
  }

  inline Direct_RBC_Tag& operator=(const Direct_RBC_Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Direct_RBC_Tag& operator=(Direct_RBC_Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Direct_RBC_Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Direct_RBC_Tag* internal_default_instance() {
    return reinterpret_cast<const Direct_RBC_Tag*>(
               &_Direct_RBC_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Direct_RBC_Tag& a, Direct_RBC_Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(Direct_RBC_Tag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Direct_RBC_Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Direct_RBC_Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Direct_RBC_Tag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Direct_RBC_Tag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Direct_RBC_Tag& from) {
    Direct_RBC_Tag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Direct_RBC_Tag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Direct.RBC.Tag";
  }
  protected:
  explicit Direct_RBC_Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kRankFieldNumber = 2,
    kSeqFieldNumber = 3,
  };
  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint32_t channel_id() const;
  void set_channel_id(uint32_t value);
  private:
  uint32_t _internal_channel_id() const;
  void _internal_set_channel_id(uint32_t value);
  public:

  // required uint32 rank = 2;
  bool has_rank() const;
  private:
  bool _internal_has_rank() const;
  public:
  void clear_rank();
  uint32_t rank() const;
  void set_rank(uint32_t value);
  private:
  uint32_t _internal_rank() const;
  void _internal_set_rank(uint32_t value);
  public:

  // required uint32 seq = 3;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  uint32_t seq() const;
  void set_seq(uint32_t value);
  private:
  uint32_t _internal_seq() const;
  void _internal_set_seq(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Direct.RBC.Tag)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t channel_id_;
    uint32_t rank_;
    uint32_t seq_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Direct_RBC_Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Direct.RBC.Message) */ {
 public:
  inline Direct_RBC_Message() : Direct_RBC_Message(nullptr) {}
  ~Direct_RBC_Message() override;
  explicit PROTOBUF_CONSTEXPR Direct_RBC_Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Direct_RBC_Message(const Direct_RBC_Message& from);
  Direct_RBC_Message(Direct_RBC_Message&& from) noexcept
    : Direct_RBC_Message() {
    *this = ::std::move(from);
  }

  inline Direct_RBC_Message& operator=(const Direct_RBC_Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Direct_RBC_Message& operator=(Direct_RBC_Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Direct_RBC_Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Direct_RBC_Message* internal_default_instance() {
    return reinterpret_cast<const Direct_RBC_Message*>(
               &_Direct_RBC_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Direct_RBC_Message& a, Direct_RBC_Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Direct_RBC_Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Direct_RBC_Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Direct_RBC_Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Direct_RBC_Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Direct_RBC_Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Direct_RBC_Message& from) {
    Direct_RBC_Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Direct_RBC_Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Direct.RBC.Message";
  }
  protected:
  explicit Direct_RBC_Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
  };
  // required bytes message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Direct.RBC.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Direct_RBC_Hash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Direct.RBC.Hash) */ {
 public:
  inline Direct_RBC_Hash() : Direct_RBC_Hash(nullptr) {}
  ~Direct_RBC_Hash() override;
  explicit PROTOBUF_CONSTEXPR Direct_RBC_Hash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Direct_RBC_Hash(const Direct_RBC_Hash& from);
  Direct_RBC_Hash(Direct_RBC_Hash&& from) noexcept
    : Direct_RBC_Hash() {
    *this = ::std::move(from);
  }

  inline Direct_RBC_Hash& operator=(const Direct_RBC_Hash& from) {
    CopyFrom(from);
    return *this;
  }
  inline Direct_RBC_Hash& operator=(Direct_RBC_Hash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Direct_RBC_Hash& default_instance() {
    return *internal_default_instance();
  }
  static inline const Direct_RBC_Hash* internal_default_instance() {
    return reinterpret_cast<const Direct_RBC_Hash*>(
               &_Direct_RBC_Hash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Direct_RBC_Hash& a, Direct_RBC_Hash& b) {
    a.Swap(&b);
  }
  inline void Swap(Direct_RBC_Hash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Direct_RBC_Hash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Direct_RBC_Hash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Direct_RBC_Hash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Direct_RBC_Hash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Direct_RBC_Hash& from) {
    Direct_RBC_Hash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Direct_RBC_Hash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Direct.RBC.Hash";
  }
  protected:
  explicit Direct_RBC_Hash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgHashFieldNumber = 2,
  };
  // required string msg_hash = 2;
  bool has_msg_hash() const;
  private:
  bool _internal_has_msg_hash() const;
  public:
  void clear_msg_hash();
  const std::string& msg_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_hash();
  PROTOBUF_NODISCARD std::string* release_msg_hash();
  void set_allocated_msg_hash(std::string* msg_hash);
  private:
  const std::string& _internal_msg_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_hash(const std::string& value);
  std::string* _internal_mutable_msg_hash();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Direct.RBC.Hash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_hash_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Direct_RBC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Direct.RBC) */ {
 public:
  inline Direct_RBC() : Direct_RBC(nullptr) {}
  ~Direct_RBC() override;
  explicit PROTOBUF_CONSTEXPR Direct_RBC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Direct_RBC(const Direct_RBC& from);
  Direct_RBC(Direct_RBC&& from) noexcept
    : Direct_RBC() {
    *this = ::std::move(from);
  }

  inline Direct_RBC& operator=(const Direct_RBC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Direct_RBC& operator=(Direct_RBC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Direct_RBC& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kBroadcast = 2,
    kEcho = 3,
    kReady = 4,
    kRequest = 5,
    kAnswer = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Direct_RBC* internal_default_instance() {
    return reinterpret_cast<const Direct_RBC*>(
               &_Direct_RBC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Direct_RBC& a, Direct_RBC& b) {
    a.Swap(&b);
  }
  inline void Swap(Direct_RBC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Direct_RBC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Direct_RBC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Direct_RBC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Direct_RBC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Direct_RBC& from) {
    Direct_RBC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Direct_RBC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Direct.RBC";
  }
  protected:
  explicit Direct_RBC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Direct_RBC_Tag Tag;
  typedef Direct_RBC_Message Message;
  typedef Direct_RBC_Hash Hash;

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kBroadcastFieldNumber = 2,
    kEchoFieldNumber = 3,
    kReadyFieldNumber = 4,
    kRequestFieldNumber = 5,
    kAnswerFieldNumber = 6,
  };
  // required .fetch.consensus.pb.Direct.RBC.Tag tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const ::fetch::consensus::pb::Direct_RBC_Tag& tag() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC_Tag* release_tag();
  ::fetch::consensus::pb::Direct_RBC_Tag* mutable_tag();
  void set_allocated_tag(::fetch::consensus::pb::Direct_RBC_Tag* tag);
  private:
  const ::fetch::consensus::pb::Direct_RBC_Tag& _internal_tag() const;
  ::fetch::consensus::pb::Direct_RBC_Tag* _internal_mutable_tag();
  public:
  void unsafe_arena_set_allocated_tag(
      ::fetch::consensus::pb::Direct_RBC_Tag* tag);
  ::fetch::consensus::pb::Direct_RBC_Tag* unsafe_arena_release_tag();

  // .fetch.consensus.pb.Direct.RBC.Message broadcast = 2;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::fetch::consensus::pb::Direct_RBC_Message& broadcast() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC_Message* release_broadcast();
  ::fetch::consensus::pb::Direct_RBC_Message* mutable_broadcast();
  void set_allocated_broadcast(::fetch::consensus::pb::Direct_RBC_Message* broadcast);
  private:
  const ::fetch::consensus::pb::Direct_RBC_Message& _internal_broadcast() const;
  ::fetch::consensus::pb::Direct_RBC_Message* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::fetch::consensus::pb::Direct_RBC_Message* broadcast);
  ::fetch::consensus::pb::Direct_RBC_Message* unsafe_arena_release_broadcast();

  // .fetch.consensus.pb.Direct.RBC.Hash echo = 3;
  bool has_echo() const;
  private:
  bool _internal_has_echo() const;
  public:
  void clear_echo();
  const ::fetch::consensus::pb::Direct_RBC_Hash& echo() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC_Hash* release_echo();
  ::fetch::consensus::pb::Direct_RBC_Hash* mutable_echo();
  void set_allocated_echo(::fetch::consensus::pb::Direct_RBC_Hash* echo);
  private:
  const ::fetch::consensus::pb::Direct_RBC_Hash& _internal_echo() const;
  ::fetch::consensus::pb::Direct_RBC_Hash* _internal_mutable_echo();
  public:
  void unsafe_arena_set_allocated_echo(
      ::fetch::consensus::pb::Direct_RBC_Hash* echo);
  ::fetch::consensus::pb::Direct_RBC_Hash* unsafe_arena_release_echo();

  // .fetch.consensus.pb.Direct.RBC.Hash ready = 4;
  bool has_ready() const;
  private:
  bool _internal_has_ready() const;
  public:
  void clear_ready();
  const ::fetch::consensus::pb::Direct_RBC_Hash& ready() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC_Hash* release_ready();
  ::fetch::consensus::pb::Direct_RBC_Hash* mutable_ready();
  void set_allocated_ready(::fetch::consensus::pb::Direct_RBC_Hash* ready);
  private:
  const ::fetch::consensus::pb::Direct_RBC_Hash& _internal_ready() const;
  ::fetch::consensus::pb::Direct_RBC_Hash* _internal_mutable_ready();
  public:
  void unsafe_arena_set_allocated_ready(
      ::fetch::consensus::pb::Direct_RBC_Hash* ready);
  ::fetch::consensus::pb::Direct_RBC_Hash* unsafe_arena_release_ready();

  // .fetch.consensus.pb.Direct.RBC.Hash request = 5;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::fetch::consensus::pb::Direct_RBC_Hash& request() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC_Hash* release_request();
  ::fetch::consensus::pb::Direct_RBC_Hash* mutable_request();
  void set_allocated_request(::fetch::consensus::pb::Direct_RBC_Hash* request);
  private:
  const ::fetch::consensus::pb::Direct_RBC_Hash& _internal_request() const;
  ::fetch::consensus::pb::Direct_RBC_Hash* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::fetch::consensus::pb::Direct_RBC_Hash* request);
  ::fetch::consensus::pb::Direct_RBC_Hash* unsafe_arena_release_request();

  // .fetch.consensus.pb.Direct.RBC.Message answer = 6;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::fetch::consensus::pb::Direct_RBC_Message& answer() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC_Message* release_answer();
  ::fetch::consensus::pb::Direct_RBC_Message* mutable_answer();
  void set_allocated_answer(::fetch::consensus::pb::Direct_RBC_Message* answer);
  private:
  const ::fetch::consensus::pb::Direct_RBC_Message& _internal_answer() const;
  ::fetch::consensus::pb::Direct_RBC_Message* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::fetch::consensus::pb::Direct_RBC_Message* answer);
  ::fetch::consensus::pb::Direct_RBC_Message* unsafe_arena_release_answer();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Direct.RBC)
 private:
  class _Internal;
  void set_has_broadcast();
  void set_has_echo();
  void set_has_ready();
  void set_has_request();
  void set_has_answer();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::fetch::consensus::pb::Direct_RBC_Tag* tag_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::fetch::consensus::pb::Direct_RBC_Message* broadcast_;
      ::fetch::consensus::pb::Direct_RBC_Hash* echo_;
      ::fetch::consensus::pb::Direct_RBC_Hash* ready_;
      ::fetch::consensus::pb::Direct_RBC_Hash* request_;
      ::fetch::consensus::pb::Direct_RBC_Message* answer_;
    } payload_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Direct_NoiseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Direct.NoiseMessage) */ {
 public:
  inline Direct_NoiseMessage() : Direct_NoiseMessage(nullptr) {}
  ~Direct_NoiseMessage() override;
  explicit PROTOBUF_CONSTEXPR Direct_NoiseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Direct_NoiseMessage(const Direct_NoiseMessage& from);
  Direct_NoiseMessage(Direct_NoiseMessage&& from) noexcept
    : Direct_NoiseMessage() {
    *this = ::std::move(from);
  }

  inline Direct_NoiseMessage& operator=(const Direct_NoiseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Direct_NoiseMessage& operator=(Direct_NoiseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Direct_NoiseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Direct_NoiseMessage* internal_default_instance() {
    return reinterpret_cast<const Direct_NoiseMessage*>(
               &_Direct_NoiseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Direct_NoiseMessage& a, Direct_NoiseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Direct_NoiseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Direct_NoiseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Direct_NoiseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Direct_NoiseMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Direct_NoiseMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Direct_NoiseMessage& from) {
    Direct_NoiseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Direct_NoiseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Direct.NoiseMessage";
  }
  protected:
  explicit Direct_NoiseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // repeated uint32 payload = 1;
  int payload_size() const;
  private:
  int _internal_payload_size() const;
  public:
  void clear_payload();
  private:
  uint32_t _internal_payload(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_payload() const;
  void _internal_add_payload(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_payload();
  public:
  uint32_t payload(int index) const;
  void set_payload(int index, uint32_t value);
  void add_payload(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      payload() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_payload();

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Direct.NoiseMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Direct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Direct) */ {
 public:
  inline Direct() : Direct(nullptr) {}
  ~Direct() override;
  explicit PROTOBUF_CONSTEXPR Direct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Direct(const Direct& from);
  Direct(Direct&& from) noexcept
    : Direct() {
    *this = ::std::move(from);
  }

  inline Direct& operator=(const Direct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Direct& operator=(Direct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Direct& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kRbcMsg = 2,
    kHandshake = 3,
    kEncryptedCipher = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Direct* internal_default_instance() {
    return reinterpret_cast<const Direct*>(
               &_Direct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Direct& a, Direct& b) {
    a.Swap(&b);
  }
  inline void Swap(Direct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Direct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Direct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Direct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Direct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Direct& from) {
    Direct::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Direct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Direct";
  }
  protected:
  explicit Direct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Direct_RBC RBC;
  typedef Direct_NoiseMessage NoiseMessage;

  // accessors -------------------------------------------------------

  enum : int {
    kCommitteeIdFieldNumber = 1,
    kRbcMsgFieldNumber = 2,
    kHandshakeFieldNumber = 3,
    kEncryptedCipherFieldNumber = 4,
  };
  // required uint32 committee_id = 1;
  bool has_committee_id() const;
  private:
  bool _internal_has_committee_id() const;
  public:
  void clear_committee_id();
  uint32_t committee_id() const;
  void set_committee_id(uint32_t value);
  private:
  uint32_t _internal_committee_id() const;
  void _internal_set_committee_id(uint32_t value);
  public:

  // .fetch.consensus.pb.Direct.RBC rbc_msg = 2;
  bool has_rbc_msg() const;
  private:
  bool _internal_has_rbc_msg() const;
  public:
  void clear_rbc_msg();
  const ::fetch::consensus::pb::Direct_RBC& rbc_msg() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_RBC* release_rbc_msg();
  ::fetch::consensus::pb::Direct_RBC* mutable_rbc_msg();
  void set_allocated_rbc_msg(::fetch::consensus::pb::Direct_RBC* rbc_msg);
  private:
  const ::fetch::consensus::pb::Direct_RBC& _internal_rbc_msg() const;
  ::fetch::consensus::pb::Direct_RBC* _internal_mutable_rbc_msg();
  public:
  void unsafe_arena_set_allocated_rbc_msg(
      ::fetch::consensus::pb::Direct_RBC* rbc_msg);
  ::fetch::consensus::pb::Direct_RBC* unsafe_arena_release_rbc_msg();

  // .fetch.consensus.pb.Direct.NoiseMessage handshake = 3;
  bool has_handshake() const;
  private:
  bool _internal_has_handshake() const;
  public:
  void clear_handshake();
  const ::fetch::consensus::pb::Direct_NoiseMessage& handshake() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_NoiseMessage* release_handshake();
  ::fetch::consensus::pb::Direct_NoiseMessage* mutable_handshake();
  void set_allocated_handshake(::fetch::consensus::pb::Direct_NoiseMessage* handshake);
  private:
  const ::fetch::consensus::pb::Direct_NoiseMessage& _internal_handshake() const;
  ::fetch::consensus::pb::Direct_NoiseMessage* _internal_mutable_handshake();
  public:
  void unsafe_arena_set_allocated_handshake(
      ::fetch::consensus::pb::Direct_NoiseMessage* handshake);
  ::fetch::consensus::pb::Direct_NoiseMessage* unsafe_arena_release_handshake();

  // .fetch.consensus.pb.Direct.NoiseMessage encrypted_cipher = 4;
  bool has_encrypted_cipher() const;
  private:
  bool _internal_has_encrypted_cipher() const;
  public:
  void clear_encrypted_cipher();
  const ::fetch::consensus::pb::Direct_NoiseMessage& encrypted_cipher() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Direct_NoiseMessage* release_encrypted_cipher();
  ::fetch::consensus::pb::Direct_NoiseMessage* mutable_encrypted_cipher();
  void set_allocated_encrypted_cipher(::fetch::consensus::pb::Direct_NoiseMessage* encrypted_cipher);
  private:
  const ::fetch::consensus::pb::Direct_NoiseMessage& _internal_encrypted_cipher() const;
  ::fetch::consensus::pb::Direct_NoiseMessage* _internal_mutable_encrypted_cipher();
  public:
  void unsafe_arena_set_allocated_encrypted_cipher(
      ::fetch::consensus::pb::Direct_NoiseMessage* encrypted_cipher);
  ::fetch::consensus::pb::Direct_NoiseMessage* unsafe_arena_release_encrypted_cipher();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Direct)
 private:
  class _Internal;
  void set_has_rbc_msg();
  void set_has_handshake();
  void set_has_encrypted_cipher();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t committee_id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::fetch::consensus::pb::Direct_RBC* rbc_msg_;
      ::fetch::consensus::pb::Direct_NoiseMessage* handshake_;
      ::fetch::consensus::pb::Direct_NoiseMessage* encrypted_cipher_;
    } payload_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Broadcast_Committee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Broadcast.Committee) */ {
 public:
  inline Broadcast_Committee() : Broadcast_Committee(nullptr) {}
  ~Broadcast_Committee() override;
  explicit PROTOBUF_CONSTEXPR Broadcast_Committee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Broadcast_Committee(const Broadcast_Committee& from);
  Broadcast_Committee(Broadcast_Committee&& from) noexcept
    : Broadcast_Committee() {
    *this = ::std::move(from);
  }

  inline Broadcast_Committee& operator=(const Broadcast_Committee& from) {
    CopyFrom(from);
    return *this;
  }
  inline Broadcast_Committee& operator=(Broadcast_Committee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Broadcast_Committee& default_instance() {
    return *internal_default_instance();
  }
  static inline const Broadcast_Committee* internal_default_instance() {
    return reinterpret_cast<const Broadcast_Committee*>(
               &_Broadcast_Committee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Broadcast_Committee& a, Broadcast_Committee& b) {
    a.Swap(&b);
  }
  inline void Swap(Broadcast_Committee* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Broadcast_Committee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Broadcast_Committee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Broadcast_Committee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Broadcast_Committee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Broadcast_Committee& from) {
    Broadcast_Committee::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Broadcast_Committee* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Broadcast.Committee";
  }
  protected:
  explicit Broadcast_Committee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated string nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  const std::string& nodes(int index) const;
  std::string* mutable_nodes(int index);
  void set_nodes(int index, const std::string& value);
  void set_nodes(int index, std::string&& value);
  void set_nodes(int index, const char* value);
  void set_nodes(int index, const char* value, size_t size);
  std::string* add_nodes();
  void add_nodes(const std::string& value);
  void add_nodes(std::string&& value);
  void add_nodes(const char* value);
  void add_nodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nodes();
  private:
  const std::string& _internal_nodes(int index) const;
  std::string* _internal_add_nodes();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Broadcast.Committee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Broadcast_Complaints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Broadcast.Complaints) */ {
 public:
  inline Broadcast_Complaints() : Broadcast_Complaints(nullptr) {}
  ~Broadcast_Complaints() override;
  explicit PROTOBUF_CONSTEXPR Broadcast_Complaints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Broadcast_Complaints(const Broadcast_Complaints& from);
  Broadcast_Complaints(Broadcast_Complaints&& from) noexcept
    : Broadcast_Complaints() {
    *this = ::std::move(from);
  }

  inline Broadcast_Complaints& operator=(const Broadcast_Complaints& from) {
    CopyFrom(from);
    return *this;
  }
  inline Broadcast_Complaints& operator=(Broadcast_Complaints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Broadcast_Complaints& default_instance() {
    return *internal_default_instance();
  }
  static inline const Broadcast_Complaints* internal_default_instance() {
    return reinterpret_cast<const Broadcast_Complaints*>(
               &_Broadcast_Complaints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Broadcast_Complaints& a, Broadcast_Complaints& b) {
    a.Swap(&b);
  }
  inline void Swap(Broadcast_Complaints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Broadcast_Complaints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Broadcast_Complaints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Broadcast_Complaints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Broadcast_Complaints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Broadcast_Complaints& from) {
    Broadcast_Complaints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Broadcast_Complaints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Broadcast.Complaints";
  }
  protected:
  explicit Broadcast_Complaints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated string nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  const std::string& nodes(int index) const;
  std::string* mutable_nodes(int index);
  void set_nodes(int index, const std::string& value);
  void set_nodes(int index, std::string&& value);
  void set_nodes(int index, const char* value);
  void set_nodes(int index, const char* value, size_t size);
  std::string* add_nodes();
  void add_nodes(const std::string& value);
  void add_nodes(std::string&& value);
  void add_nodes(const char* value);
  void add_nodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nodes();
  private:
  const std::string& _internal_nodes(int index) const;
  std::string* _internal_add_nodes();
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Broadcast.Complaints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Broadcast_Shares final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Broadcast.Shares) */ {
 public:
  inline Broadcast_Shares() : Broadcast_Shares(nullptr) {}
  ~Broadcast_Shares() override;
  explicit PROTOBUF_CONSTEXPR Broadcast_Shares(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Broadcast_Shares(const Broadcast_Shares& from);
  Broadcast_Shares(Broadcast_Shares&& from) noexcept
    : Broadcast_Shares() {
    *this = ::std::move(from);
  }

  inline Broadcast_Shares& operator=(const Broadcast_Shares& from) {
    CopyFrom(from);
    return *this;
  }
  inline Broadcast_Shares& operator=(Broadcast_Shares&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Broadcast_Shares& default_instance() {
    return *internal_default_instance();
  }
  static inline const Broadcast_Shares* internal_default_instance() {
    return reinterpret_cast<const Broadcast_Shares*>(
               &_Broadcast_Shares_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Broadcast_Shares& a, Broadcast_Shares& b) {
    a.Swap(&b);
  }
  inline void Swap(Broadcast_Shares* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Broadcast_Shares* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Broadcast_Shares* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Broadcast_Shares>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Broadcast_Shares& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Broadcast_Shares& from) {
    Broadcast_Shares::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Broadcast_Shares* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Broadcast.Shares";
  }
  protected:
  explicit Broadcast_Shares(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 2,
    kSecondFieldNumber = 3,
    kReporterFieldNumber = 4,
    kPhaseFieldNumber = 1,
  };
  // repeated string first = 2;
  int first_size() const;
  private:
  int _internal_first_size() const;
  public:
  void clear_first();
  const std::string& first(int index) const;
  std::string* mutable_first(int index);
  void set_first(int index, const std::string& value);
  void set_first(int index, std::string&& value);
  void set_first(int index, const char* value);
  void set_first(int index, const char* value, size_t size);
  std::string* add_first();
  void add_first(const std::string& value);
  void add_first(std::string&& value);
  void add_first(const char* value);
  void add_first(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& first() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_first();
  private:
  const std::string& _internal_first(int index) const;
  std::string* _internal_add_first();
  public:

  // repeated string second = 3;
  int second_size() const;
  private:
  int _internal_second_size() const;
  public:
  void clear_second();
  const std::string& second(int index) const;
  std::string* mutable_second(int index);
  void set_second(int index, const std::string& value);
  void set_second(int index, std::string&& value);
  void set_second(int index, const char* value);
  void set_second(int index, const char* value, size_t size);
  std::string* add_second();
  void add_second(const std::string& value);
  void add_second(std::string&& value);
  void add_second(const char* value);
  void add_second(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& second() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_second();
  private:
  const std::string& _internal_second(int index) const;
  std::string* _internal_add_second();
  public:

  // repeated string reporter = 4;
  int reporter_size() const;
  private:
  int _internal_reporter_size() const;
  public:
  void clear_reporter();
  const std::string& reporter(int index) const;
  std::string* mutable_reporter(int index);
  void set_reporter(int index, const std::string& value);
  void set_reporter(int index, std::string&& value);
  void set_reporter(int index, const char* value);
  void set_reporter(int index, const char* value, size_t size);
  std::string* add_reporter();
  void add_reporter(const std::string& value);
  void add_reporter(std::string&& value);
  void add_reporter(const char* value);
  void add_reporter(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& reporter() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_reporter();
  private:
  const std::string& _internal_reporter(int index) const;
  std::string* _internal_add_reporter();
  public:

  // required uint64 phase = 1;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  uint64_t phase() const;
  void set_phase(uint64_t value);
  private:
  uint64_t _internal_phase() const;
  void _internal_set_phase(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Broadcast.Shares)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> first_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> second_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> reporter_;
    uint64_t phase_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Broadcast_Coefficients final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Broadcast.Coefficients) */ {
 public:
  inline Broadcast_Coefficients() : Broadcast_Coefficients(nullptr) {}
  ~Broadcast_Coefficients() override;
  explicit PROTOBUF_CONSTEXPR Broadcast_Coefficients(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Broadcast_Coefficients(const Broadcast_Coefficients& from);
  Broadcast_Coefficients(Broadcast_Coefficients&& from) noexcept
    : Broadcast_Coefficients() {
    *this = ::std::move(from);
  }

  inline Broadcast_Coefficients& operator=(const Broadcast_Coefficients& from) {
    CopyFrom(from);
    return *this;
  }
  inline Broadcast_Coefficients& operator=(Broadcast_Coefficients&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Broadcast_Coefficients& default_instance() {
    return *internal_default_instance();
  }
  static inline const Broadcast_Coefficients* internal_default_instance() {
    return reinterpret_cast<const Broadcast_Coefficients*>(
               &_Broadcast_Coefficients_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Broadcast_Coefficients& a, Broadcast_Coefficients& b) {
    a.Swap(&b);
  }
  inline void Swap(Broadcast_Coefficients* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Broadcast_Coefficients* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Broadcast_Coefficients* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Broadcast_Coefficients>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Broadcast_Coefficients& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Broadcast_Coefficients& from) {
    Broadcast_Coefficients::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Broadcast_Coefficients* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Broadcast.Coefficients";
  }
  protected:
  explicit Broadcast_Coefficients(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoefficientsFieldNumber = 2,
    kPhaseFieldNumber = 1,
  };
  // repeated string coefficients = 2;
  int coefficients_size() const;
  private:
  int _internal_coefficients_size() const;
  public:
  void clear_coefficients();
  const std::string& coefficients(int index) const;
  std::string* mutable_coefficients(int index);
  void set_coefficients(int index, const std::string& value);
  void set_coefficients(int index, std::string&& value);
  void set_coefficients(int index, const char* value);
  void set_coefficients(int index, const char* value, size_t size);
  std::string* add_coefficients();
  void add_coefficients(const std::string& value);
  void add_coefficients(std::string&& value);
  void add_coefficients(const char* value);
  void add_coefficients(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& coefficients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_coefficients();
  private:
  const std::string& _internal_coefficients(int index) const;
  std::string* _internal_add_coefficients();
  public:

  // required uint64 phase = 1;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  uint64_t phase() const;
  void set_phase(uint64_t value);
  private:
  uint64_t _internal_phase() const;
  void _internal_set_phase(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Broadcast.Coefficients)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> coefficients_;
    uint64_t phase_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// -------------------------------------------------------------------

class Broadcast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fetch.consensus.pb.Broadcast) */ {
 public:
  inline Broadcast() : Broadcast(nullptr) {}
  ~Broadcast() override;
  explicit PROTOBUF_CONSTEXPR Broadcast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Broadcast(const Broadcast& from);
  Broadcast(Broadcast&& from) noexcept
    : Broadcast() {
    *this = ::std::move(from);
  }

  inline Broadcast& operator=(const Broadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline Broadcast& operator=(Broadcast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Broadcast& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kComplaints = 1,
    kShares = 2,
    kCoefficients = 3,
    kCommittee = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Broadcast* internal_default_instance() {
    return reinterpret_cast<const Broadcast*>(
               &_Broadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Broadcast& a, Broadcast& b) {
    a.Swap(&b);
  }
  inline void Swap(Broadcast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Broadcast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Broadcast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Broadcast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Broadcast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Broadcast& from) {
    Broadcast::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Broadcast* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fetch.consensus.pb.Broadcast";
  }
  protected:
  explicit Broadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Broadcast_Committee Committee;
  typedef Broadcast_Complaints Complaints;
  typedef Broadcast_Shares Shares;
  typedef Broadcast_Coefficients Coefficients;

  // accessors -------------------------------------------------------

  enum : int {
    kComplaintsFieldNumber = 1,
    kSharesFieldNumber = 2,
    kCoefficientsFieldNumber = 3,
    kCommitteeFieldNumber = 4,
  };
  // .fetch.consensus.pb.Broadcast.Complaints complaints = 1;
  bool has_complaints() const;
  private:
  bool _internal_has_complaints() const;
  public:
  void clear_complaints();
  const ::fetch::consensus::pb::Broadcast_Complaints& complaints() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Broadcast_Complaints* release_complaints();
  ::fetch::consensus::pb::Broadcast_Complaints* mutable_complaints();
  void set_allocated_complaints(::fetch::consensus::pb::Broadcast_Complaints* complaints);
  private:
  const ::fetch::consensus::pb::Broadcast_Complaints& _internal_complaints() const;
  ::fetch::consensus::pb::Broadcast_Complaints* _internal_mutable_complaints();
  public:
  void unsafe_arena_set_allocated_complaints(
      ::fetch::consensus::pb::Broadcast_Complaints* complaints);
  ::fetch::consensus::pb::Broadcast_Complaints* unsafe_arena_release_complaints();

  // .fetch.consensus.pb.Broadcast.Shares shares = 2;
  bool has_shares() const;
  private:
  bool _internal_has_shares() const;
  public:
  void clear_shares();
  const ::fetch::consensus::pb::Broadcast_Shares& shares() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Broadcast_Shares* release_shares();
  ::fetch::consensus::pb::Broadcast_Shares* mutable_shares();
  void set_allocated_shares(::fetch::consensus::pb::Broadcast_Shares* shares);
  private:
  const ::fetch::consensus::pb::Broadcast_Shares& _internal_shares() const;
  ::fetch::consensus::pb::Broadcast_Shares* _internal_mutable_shares();
  public:
  void unsafe_arena_set_allocated_shares(
      ::fetch::consensus::pb::Broadcast_Shares* shares);
  ::fetch::consensus::pb::Broadcast_Shares* unsafe_arena_release_shares();

  // .fetch.consensus.pb.Broadcast.Coefficients coefficients = 3;
  bool has_coefficients() const;
  private:
  bool _internal_has_coefficients() const;
  public:
  void clear_coefficients();
  const ::fetch::consensus::pb::Broadcast_Coefficients& coefficients() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Broadcast_Coefficients* release_coefficients();
  ::fetch::consensus::pb::Broadcast_Coefficients* mutable_coefficients();
  void set_allocated_coefficients(::fetch::consensus::pb::Broadcast_Coefficients* coefficients);
  private:
  const ::fetch::consensus::pb::Broadcast_Coefficients& _internal_coefficients() const;
  ::fetch::consensus::pb::Broadcast_Coefficients* _internal_mutable_coefficients();
  public:
  void unsafe_arena_set_allocated_coefficients(
      ::fetch::consensus::pb::Broadcast_Coefficients* coefficients);
  ::fetch::consensus::pb::Broadcast_Coefficients* unsafe_arena_release_coefficients();

  // .fetch.consensus.pb.Broadcast.Committee committee = 4;
  bool has_committee() const;
  private:
  bool _internal_has_committee() const;
  public:
  void clear_committee();
  const ::fetch::consensus::pb::Broadcast_Committee& committee() const;
  PROTOBUF_NODISCARD ::fetch::consensus::pb::Broadcast_Committee* release_committee();
  ::fetch::consensus::pb::Broadcast_Committee* mutable_committee();
  void set_allocated_committee(::fetch::consensus::pb::Broadcast_Committee* committee);
  private:
  const ::fetch::consensus::pb::Broadcast_Committee& _internal_committee() const;
  ::fetch::consensus::pb::Broadcast_Committee* _internal_mutable_committee();
  public:
  void unsafe_arena_set_allocated_committee(
      ::fetch::consensus::pb::Broadcast_Committee* committee);
  ::fetch::consensus::pb::Broadcast_Committee* unsafe_arena_release_committee();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:fetch.consensus.pb.Broadcast)
 private:
  class _Internal;
  void set_has_complaints();
  void set_has_shares();
  void set_has_coefficients();
  void set_has_committee();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::fetch::consensus::pb::Broadcast_Complaints* complaints_;
      ::fetch::consensus::pb::Broadcast_Shares* shares_;
      ::fetch::consensus::pb::Broadcast_Coefficients* coefficients_;
      ::fetch::consensus::pb::Broadcast_Committee* committee_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_consensus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Neighbour

// required string id = 1;
inline bool Neighbour::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Neighbour::has_id() const {
  return _internal_has_id();
}
inline void Neighbour::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Neighbour::id() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Neighbour.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Neighbour::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Neighbour.id)
}
inline std::string* Neighbour::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Neighbour.id)
  return _s;
}
inline const std::string& Neighbour::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Neighbour::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Neighbour::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Neighbour::release_id() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Neighbour.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Neighbour::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Neighbour.id)
}

// required uint32 port = 2;
inline bool Neighbour::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Neighbour::has_port() const {
  return _internal_has_port();
}
inline void Neighbour::clear_port() {
  _impl_.port_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Neighbour::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t Neighbour::port() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Neighbour.port)
  return _internal_port();
}
inline void Neighbour::_internal_set_port(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.port_ = value;
}
inline void Neighbour::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Neighbour.port)
}

// required string public_key = 3;
inline bool Neighbour::_internal_has_public_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Neighbour::has_public_key() const {
  return _internal_has_public_key();
}
inline void Neighbour::clear_public_key() {
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Neighbour::public_key() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Neighbour.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Neighbour::set_public_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.public_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Neighbour.public_key)
}
inline std::string* Neighbour::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Neighbour.public_key)
  return _s;
}
inline const std::string& Neighbour::_internal_public_key() const {
  return _impl_.public_key_.Get();
}
inline void Neighbour::_internal_set_public_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Neighbour::_internal_mutable_public_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Neighbour::release_public_key() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Neighbour.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Neighbour::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Neighbour.public_key)
}

// repeated uint32 dh_public_key = 4;
inline int Neighbour::_internal_dh_public_key_size() const {
  return _impl_.dh_public_key_.size();
}
inline int Neighbour::dh_public_key_size() const {
  return _internal_dh_public_key_size();
}
inline void Neighbour::clear_dh_public_key() {
  _impl_.dh_public_key_.Clear();
}
inline uint32_t Neighbour::_internal_dh_public_key(int index) const {
  return _impl_.dh_public_key_.Get(index);
}
inline uint32_t Neighbour::dh_public_key(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Neighbour.dh_public_key)
  return _internal_dh_public_key(index);
}
inline void Neighbour::set_dh_public_key(int index, uint32_t value) {
  _impl_.dh_public_key_.Set(index, value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Neighbour.dh_public_key)
}
inline void Neighbour::_internal_add_dh_public_key(uint32_t value) {
  _impl_.dh_public_key_.Add(value);
}
inline void Neighbour::add_dh_public_key(uint32_t value) {
  _internal_add_dh_public_key(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Neighbour.dh_public_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Neighbour::_internal_dh_public_key() const {
  return _impl_.dh_public_key_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Neighbour::dh_public_key() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Neighbour.dh_public_key)
  return _internal_dh_public_key();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Neighbour::_internal_mutable_dh_public_key() {
  return &_impl_.dh_public_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Neighbour::mutable_dh_public_key() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Neighbour.dh_public_key)
  return _internal_mutable_dh_public_key();
}

// repeated uint32 key_signature = 5;
inline int Neighbour::_internal_key_signature_size() const {
  return _impl_.key_signature_.size();
}
inline int Neighbour::key_signature_size() const {
  return _internal_key_signature_size();
}
inline void Neighbour::clear_key_signature() {
  _impl_.key_signature_.Clear();
}
inline uint32_t Neighbour::_internal_key_signature(int index) const {
  return _impl_.key_signature_.Get(index);
}
inline uint32_t Neighbour::key_signature(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Neighbour.key_signature)
  return _internal_key_signature(index);
}
inline void Neighbour::set_key_signature(int index, uint32_t value) {
  _impl_.key_signature_.Set(index, value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Neighbour.key_signature)
}
inline void Neighbour::_internal_add_key_signature(uint32_t value) {
  _impl_.key_signature_.Add(value);
}
inline void Neighbour::add_key_signature(uint32_t value) {
  _internal_add_key_signature(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Neighbour.key_signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Neighbour::_internal_key_signature() const {
  return _impl_.key_signature_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Neighbour::key_signature() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Neighbour.key_signature)
  return _internal_key_signature();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Neighbour::_internal_mutable_key_signature() {
  return &_impl_.key_signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Neighbour::mutable_key_signature() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Neighbour.key_signature)
  return _internal_mutable_key_signature();
}

// -------------------------------------------------------------------

// PrivateShares

// required string first = 1;
inline bool PrivateShares::_internal_has_first() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrivateShares::has_first() const {
  return _internal_has_first();
}
inline void PrivateShares::clear_first() {
  _impl_.first_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrivateShares::first() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.PrivateShares.first)
  return _internal_first();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShares::set_first(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.first_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.PrivateShares.first)
}
inline std::string* PrivateShares::mutable_first() {
  std::string* _s = _internal_mutable_first();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.PrivateShares.first)
  return _s;
}
inline const std::string& PrivateShares::_internal_first() const {
  return _impl_.first_.Get();
}
inline void PrivateShares::_internal_set_first(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.first_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateShares::_internal_mutable_first() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.first_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateShares::release_first() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.PrivateShares.first)
  if (!_internal_has_first()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.first_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_.IsDefault()) {
    _impl_.first_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrivateShares::set_allocated_first(std::string* first) {
  if (first != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.first_.SetAllocated(first, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_.IsDefault()) {
    _impl_.first_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.PrivateShares.first)
}

// required string second = 2;
inline bool PrivateShares::_internal_has_second() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrivateShares::has_second() const {
  return _internal_has_second();
}
inline void PrivateShares::clear_second() {
  _impl_.second_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PrivateShares::second() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.PrivateShares.second)
  return _internal_second();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivateShares::set_second(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.second_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.PrivateShares.second)
}
inline std::string* PrivateShares::mutable_second() {
  std::string* _s = _internal_mutable_second();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.PrivateShares.second)
  return _s;
}
inline const std::string& PrivateShares::_internal_second() const {
  return _impl_.second_.Get();
}
inline void PrivateShares::_internal_set_second(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.second_.Set(value, GetArenaForAllocation());
}
inline std::string* PrivateShares::_internal_mutable_second() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.second_.Mutable(GetArenaForAllocation());
}
inline std::string* PrivateShares::release_second() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.PrivateShares.second)
  if (!_internal_has_second()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.second_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.second_.IsDefault()) {
    _impl_.second_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PrivateShares::set_allocated_second(std::string* second) {
  if (second != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.second_.SetAllocated(second, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.second_.IsDefault()) {
    _impl_.second_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.PrivateShares.second)
}

// -------------------------------------------------------------------

// Message_Join

// repeated string nodes = 1;
inline int Message_Join::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int Message_Join::nodes_size() const {
  return _internal_nodes_size();
}
inline void Message_Join::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline std::string* Message_Join::add_nodes() {
  std::string* _s = _internal_add_nodes();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Message.Join.nodes)
  return _s;
}
inline const std::string& Message_Join::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const std::string& Message_Join::nodes(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.Join.nodes)
  return _internal_nodes(index);
}
inline std::string* Message_Join::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Message.Join.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline void Message_Join::set_nodes(int index, const std::string& value) {
  _impl_.nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Join.nodes)
}
inline void Message_Join::set_nodes(int index, std::string&& value) {
  _impl_.nodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Join.nodes)
}
inline void Message_Join::set_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Message.Join.nodes)
}
inline void Message_Join::set_nodes(int index, const char* value, size_t size) {
  _impl_.nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Message.Join.nodes)
}
inline std::string* Message_Join::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline void Message_Join::add_nodes(const std::string& value) {
  _impl_.nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Message.Join.nodes)
}
inline void Message_Join::add_nodes(std::string&& value) {
  _impl_.nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Message.Join.nodes)
}
inline void Message_Join::add_nodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Message.Join.nodes)
}
inline void Message_Join::add_nodes(const char* value, size_t size) {
  _impl_.nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Message.Join.nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Message_Join::nodes() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Message.Join.nodes)
  return _impl_.nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Message_Join::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Message.Join.nodes)
  return &_impl_.nodes_;
}

// -------------------------------------------------------------------

// Message_Gossip

// required uint64 step = 1;
inline bool Message_Gossip::_internal_has_step() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Message_Gossip::has_step() const {
  return _internal_has_step();
}
inline void Message_Gossip::clear_step() {
  _impl_.step_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Message_Gossip::_internal_step() const {
  return _impl_.step_;
}
inline uint64_t Message_Gossip::step() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.Gossip.step)
  return _internal_step();
}
inline void Message_Gossip::_internal_set_step(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.step_ = value;
}
inline void Message_Gossip::set_step(uint64_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Gossip.step)
}

// required bool gossip = 2;
inline bool Message_Gossip::_internal_has_gossip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Message_Gossip::has_gossip() const {
  return _internal_has_gossip();
}
inline void Message_Gossip::clear_gossip() {
  _impl_.gossip_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Message_Gossip::_internal_gossip() const {
  return _impl_.gossip_;
}
inline bool Message_Gossip::gossip() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.Gossip.gossip)
  return _internal_gossip();
}
inline void Message_Gossip::_internal_set_gossip(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.gossip_ = value;
}
inline void Message_Gossip::set_gossip(bool value) {
  _internal_set_gossip(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Gossip.gossip)
}

// required bytes msg = 3;
inline bool Message_Gossip::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Message_Gossip::has_msg() const {
  return _internal_has_msg();
}
inline void Message_Gossip::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Message_Gossip::msg() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.Gossip.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message_Gossip::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Gossip.msg)
}
inline std::string* Message_Gossip::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Message.Gossip.msg)
  return _s;
}
inline const std::string& Message_Gossip::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void Message_Gossip::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Message_Gossip::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Message_Gossip::release_msg() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Message.Gossip.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Message_Gossip::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Message.Gossip.msg)
}

// required string origin = 4;
inline bool Message_Gossip::_internal_has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Message_Gossip::has_origin() const {
  return _internal_has_origin();
}
inline void Message_Gossip::clear_origin() {
  _impl_.origin_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Message_Gossip::origin() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.Gossip.origin)
  return _internal_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message_Gossip::set_origin(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.origin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Gossip.origin)
}
inline std::string* Message_Gossip::mutable_origin() {
  std::string* _s = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Message.Gossip.origin)
  return _s;
}
inline const std::string& Message_Gossip::_internal_origin() const {
  return _impl_.origin_.Get();
}
inline void Message_Gossip::_internal_set_origin(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.origin_.Set(value, GetArenaForAllocation());
}
inline std::string* Message_Gossip::_internal_mutable_origin() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.origin_.Mutable(GetArenaForAllocation());
}
inline std::string* Message_Gossip::release_origin() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Message.Gossip.origin)
  if (!_internal_has_origin()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.origin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.origin_.IsDefault()) {
    _impl_.origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Message_Gossip::set_allocated_origin(std::string* origin) {
  if (origin != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.origin_.SetAllocated(origin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.origin_.IsDefault()) {
    _impl_.origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Message.Gossip.origin)
}

// repeated uint32 signature = 5;
inline int Message_Gossip::_internal_signature_size() const {
  return _impl_.signature_.size();
}
inline int Message_Gossip::signature_size() const {
  return _internal_signature_size();
}
inline void Message_Gossip::clear_signature() {
  _impl_.signature_.Clear();
}
inline uint32_t Message_Gossip::_internal_signature(int index) const {
  return _impl_.signature_.Get(index);
}
inline uint32_t Message_Gossip::signature(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.Gossip.signature)
  return _internal_signature(index);
}
inline void Message_Gossip::set_signature(int index, uint32_t value) {
  _impl_.signature_.Set(index, value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Message.Gossip.signature)
}
inline void Message_Gossip::_internal_add_signature(uint32_t value) {
  _impl_.signature_.Add(value);
}
inline void Message_Gossip::add_signature(uint32_t value) {
  _internal_add_signature(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Message.Gossip.signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Message_Gossip::_internal_signature() const {
  return _impl_.signature_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Message_Gossip::signature() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Message.Gossip.signature)
  return _internal_signature();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Message_Gossip::_internal_mutable_signature() {
  return &_impl_.signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Message_Gossip::mutable_signature() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Message.Gossip.signature)
  return _internal_mutable_signature();
}

// -------------------------------------------------------------------

// Message

// .fetch.consensus.pb.Message.Join join = 1;
inline bool Message::_internal_has_join() const {
  return payload_case() == kJoin;
}
inline bool Message::has_join() const {
  return _internal_has_join();
}
inline void Message::set_has_join() {
  _impl_._oneof_case_[0] = kJoin;
}
inline void Message::clear_join() {
  if (_internal_has_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.join_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Message_Join* Message::release_join() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Message.join)
  if (_internal_has_join()) {
    clear_has_payload();
    ::fetch::consensus::pb::Message_Join* temp = _impl_.payload_.join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Message_Join& Message::_internal_join() const {
  return _internal_has_join()
      ? *_impl_.payload_.join_
      : reinterpret_cast< ::fetch::consensus::pb::Message_Join&>(::fetch::consensus::pb::_Message_Join_default_instance_);
}
inline const ::fetch::consensus::pb::Message_Join& Message::join() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.join)
  return _internal_join();
}
inline ::fetch::consensus::pb::Message_Join* Message::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Message.join)
  if (_internal_has_join()) {
    clear_has_payload();
    ::fetch::consensus::pb::Message_Join* temp = _impl_.payload_.join_;
    _impl_.payload_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_join(::fetch::consensus::pb::Message_Join* join) {
  clear_payload();
  if (join) {
    set_has_join();
    _impl_.payload_.join_ = join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Message.join)
}
inline ::fetch::consensus::pb::Message_Join* Message::_internal_mutable_join() {
  if (!_internal_has_join()) {
    clear_payload();
    set_has_join();
    _impl_.payload_.join_ = CreateMaybeMessage< ::fetch::consensus::pb::Message_Join >(GetArenaForAllocation());
  }
  return _impl_.payload_.join_;
}
inline ::fetch::consensus::pb::Message_Join* Message::mutable_join() {
  ::fetch::consensus::pb::Message_Join* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Message.join)
  return _msg;
}

// .fetch.consensus.pb.Message.Gossip gossip = 2;
inline bool Message::_internal_has_gossip() const {
  return payload_case() == kGossip;
}
inline bool Message::has_gossip() const {
  return _internal_has_gossip();
}
inline void Message::set_has_gossip() {
  _impl_._oneof_case_[0] = kGossip;
}
inline void Message::clear_gossip() {
  if (_internal_has_gossip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.gossip_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Message_Gossip* Message::release_gossip() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Message.gossip)
  if (_internal_has_gossip()) {
    clear_has_payload();
    ::fetch::consensus::pb::Message_Gossip* temp = _impl_.payload_.gossip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.gossip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Message_Gossip& Message::_internal_gossip() const {
  return _internal_has_gossip()
      ? *_impl_.payload_.gossip_
      : reinterpret_cast< ::fetch::consensus::pb::Message_Gossip&>(::fetch::consensus::pb::_Message_Gossip_default_instance_);
}
inline const ::fetch::consensus::pb::Message_Gossip& Message::gossip() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Message.gossip)
  return _internal_gossip();
}
inline ::fetch::consensus::pb::Message_Gossip* Message::unsafe_arena_release_gossip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Message.gossip)
  if (_internal_has_gossip()) {
    clear_has_payload();
    ::fetch::consensus::pb::Message_Gossip* temp = _impl_.payload_.gossip_;
    _impl_.payload_.gossip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_gossip(::fetch::consensus::pb::Message_Gossip* gossip) {
  clear_payload();
  if (gossip) {
    set_has_gossip();
    _impl_.payload_.gossip_ = gossip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Message.gossip)
}
inline ::fetch::consensus::pb::Message_Gossip* Message::_internal_mutable_gossip() {
  if (!_internal_has_gossip()) {
    clear_payload();
    set_has_gossip();
    _impl_.payload_.gossip_ = CreateMaybeMessage< ::fetch::consensus::pb::Message_Gossip >(GetArenaForAllocation());
  }
  return _impl_.payload_.gossip_;
}
inline ::fetch::consensus::pb::Message_Gossip* Message::mutable_gossip() {
  ::fetch::consensus::pb::Message_Gossip* _msg = _internal_mutable_gossip();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Message.gossip)
  return _msg;
}

inline bool Message::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Message::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Message::PayloadCase Message::payload_case() const {
  return Message::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Gossip_SignatureShare

// required string message = 1;
inline bool Gossip_SignatureShare::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Gossip_SignatureShare::has_message() const {
  return _internal_has_message();
}
inline void Gossip_SignatureShare::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Gossip_SignatureShare::message() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Gossip.SignatureShare.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gossip_SignatureShare::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Gossip.SignatureShare.message)
}
inline std::string* Gossip_SignatureShare::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Gossip.SignatureShare.message)
  return _s;
}
inline const std::string& Gossip_SignatureShare::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Gossip_SignatureShare::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::release_message() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Gossip.SignatureShare.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Gossip_SignatureShare::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Gossip.SignatureShare.message)
}

// required string share_sig = 2;
inline bool Gossip_SignatureShare::_internal_has_share_sig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Gossip_SignatureShare::has_share_sig() const {
  return _internal_has_share_sig();
}
inline void Gossip_SignatureShare::clear_share_sig() {
  _impl_.share_sig_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Gossip_SignatureShare::share_sig() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Gossip.SignatureShare.share_sig)
  return _internal_share_sig();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gossip_SignatureShare::set_share_sig(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.share_sig_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Gossip.SignatureShare.share_sig)
}
inline std::string* Gossip_SignatureShare::mutable_share_sig() {
  std::string* _s = _internal_mutable_share_sig();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Gossip.SignatureShare.share_sig)
  return _s;
}
inline const std::string& Gossip_SignatureShare::_internal_share_sig() const {
  return _impl_.share_sig_.Get();
}
inline void Gossip_SignatureShare::_internal_set_share_sig(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.share_sig_.Set(value, GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::_internal_mutable_share_sig() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.share_sig_.Mutable(GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::release_share_sig() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Gossip.SignatureShare.share_sig)
  if (!_internal_has_share_sig()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.share_sig_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_sig_.IsDefault()) {
    _impl_.share_sig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Gossip_SignatureShare::set_allocated_share_sig(std::string* share_sig) {
  if (share_sig != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.share_sig_.SetAllocated(share_sig, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_sig_.IsDefault()) {
    _impl_.share_sig_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Gossip.SignatureShare.share_sig)
}

// optional string share_pi = 3;
inline bool Gossip_SignatureShare::_internal_has_share_pi() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Gossip_SignatureShare::has_share_pi() const {
  return _internal_has_share_pi();
}
inline void Gossip_SignatureShare::clear_share_pi() {
  _impl_.share_pi_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Gossip_SignatureShare::share_pi() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Gossip.SignatureShare.share_pi)
  return _internal_share_pi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gossip_SignatureShare::set_share_pi(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.share_pi_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Gossip.SignatureShare.share_pi)
}
inline std::string* Gossip_SignatureShare::mutable_share_pi() {
  std::string* _s = _internal_mutable_share_pi();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Gossip.SignatureShare.share_pi)
  return _s;
}
inline const std::string& Gossip_SignatureShare::_internal_share_pi() const {
  return _impl_.share_pi_.Get();
}
inline void Gossip_SignatureShare::_internal_set_share_pi(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.share_pi_.Set(value, GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::_internal_mutable_share_pi() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.share_pi_.Mutable(GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::release_share_pi() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Gossip.SignatureShare.share_pi)
  if (!_internal_has_share_pi()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.share_pi_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_pi_.IsDefault()) {
    _impl_.share_pi_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Gossip_SignatureShare::set_allocated_share_pi(std::string* share_pi) {
  if (share_pi != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.share_pi_.SetAllocated(share_pi, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_pi_.IsDefault()) {
    _impl_.share_pi_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Gossip.SignatureShare.share_pi)
}

// optional string share_pi2 = 4;
inline bool Gossip_SignatureShare::_internal_has_share_pi2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Gossip_SignatureShare::has_share_pi2() const {
  return _internal_has_share_pi2();
}
inline void Gossip_SignatureShare::clear_share_pi2() {
  _impl_.share_pi2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Gossip_SignatureShare::share_pi2() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Gossip.SignatureShare.share_pi2)
  return _internal_share_pi2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Gossip_SignatureShare::set_share_pi2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.share_pi2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Gossip.SignatureShare.share_pi2)
}
inline std::string* Gossip_SignatureShare::mutable_share_pi2() {
  std::string* _s = _internal_mutable_share_pi2();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Gossip.SignatureShare.share_pi2)
  return _s;
}
inline const std::string& Gossip_SignatureShare::_internal_share_pi2() const {
  return _impl_.share_pi2_.Get();
}
inline void Gossip_SignatureShare::_internal_set_share_pi2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.share_pi2_.Set(value, GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::_internal_mutable_share_pi2() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.share_pi2_.Mutable(GetArenaForAllocation());
}
inline std::string* Gossip_SignatureShare::release_share_pi2() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Gossip.SignatureShare.share_pi2)
  if (!_internal_has_share_pi2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.share_pi2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_pi2_.IsDefault()) {
    _impl_.share_pi2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Gossip_SignatureShare::set_allocated_share_pi2(std::string* share_pi2) {
  if (share_pi2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.share_pi2_.SetAllocated(share_pi2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.share_pi2_.IsDefault()) {
    _impl_.share_pi2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Gossip.SignatureShare.share_pi2)
}

// -------------------------------------------------------------------

// Gossip

// .fetch.consensus.pb.Gossip.SignatureShare sig_share = 1;
inline bool Gossip::_internal_has_sig_share() const {
  return payload_case() == kSigShare;
}
inline bool Gossip::has_sig_share() const {
  return _internal_has_sig_share();
}
inline void Gossip::set_has_sig_share() {
  _impl_._oneof_case_[0] = kSigShare;
}
inline void Gossip::clear_sig_share() {
  if (_internal_has_sig_share()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.sig_share_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Gossip_SignatureShare* Gossip::release_sig_share() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Gossip.sig_share)
  if (_internal_has_sig_share()) {
    clear_has_payload();
    ::fetch::consensus::pb::Gossip_SignatureShare* temp = _impl_.payload_.sig_share_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.sig_share_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Gossip_SignatureShare& Gossip::_internal_sig_share() const {
  return _internal_has_sig_share()
      ? *_impl_.payload_.sig_share_
      : reinterpret_cast< ::fetch::consensus::pb::Gossip_SignatureShare&>(::fetch::consensus::pb::_Gossip_SignatureShare_default_instance_);
}
inline const ::fetch::consensus::pb::Gossip_SignatureShare& Gossip::sig_share() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Gossip.sig_share)
  return _internal_sig_share();
}
inline ::fetch::consensus::pb::Gossip_SignatureShare* Gossip::unsafe_arena_release_sig_share() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Gossip.sig_share)
  if (_internal_has_sig_share()) {
    clear_has_payload();
    ::fetch::consensus::pb::Gossip_SignatureShare* temp = _impl_.payload_.sig_share_;
    _impl_.payload_.sig_share_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Gossip::unsafe_arena_set_allocated_sig_share(::fetch::consensus::pb::Gossip_SignatureShare* sig_share) {
  clear_payload();
  if (sig_share) {
    set_has_sig_share();
    _impl_.payload_.sig_share_ = sig_share;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Gossip.sig_share)
}
inline ::fetch::consensus::pb::Gossip_SignatureShare* Gossip::_internal_mutable_sig_share() {
  if (!_internal_has_sig_share()) {
    clear_payload();
    set_has_sig_share();
    _impl_.payload_.sig_share_ = CreateMaybeMessage< ::fetch::consensus::pb::Gossip_SignatureShare >(GetArenaForAllocation());
  }
  return _impl_.payload_.sig_share_;
}
inline ::fetch::consensus::pb::Gossip_SignatureShare* Gossip::mutable_sig_share() {
  ::fetch::consensus::pb::Gossip_SignatureShare* _msg = _internal_mutable_sig_share();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Gossip.sig_share)
  return _msg;
}

inline bool Gossip::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Gossip::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Gossip::PayloadCase Gossip::payload_case() const {
  return Gossip::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Direct_RBC_Tag

// required uint32 channel_id = 1;
inline bool Direct_RBC_Tag::_internal_has_channel_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Direct_RBC_Tag::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void Direct_RBC_Tag::clear_channel_id() {
  _impl_.channel_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Direct_RBC_Tag::_internal_channel_id() const {
  return _impl_.channel_id_;
}
inline uint32_t Direct_RBC_Tag::channel_id() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.Tag.channel_id)
  return _internal_channel_id();
}
inline void Direct_RBC_Tag::_internal_set_channel_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.channel_id_ = value;
}
inline void Direct_RBC_Tag::set_channel_id(uint32_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.RBC.Tag.channel_id)
}

// required uint32 rank = 2;
inline bool Direct_RBC_Tag::_internal_has_rank() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Direct_RBC_Tag::has_rank() const {
  return _internal_has_rank();
}
inline void Direct_RBC_Tag::clear_rank() {
  _impl_.rank_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Direct_RBC_Tag::_internal_rank() const {
  return _impl_.rank_;
}
inline uint32_t Direct_RBC_Tag::rank() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.Tag.rank)
  return _internal_rank();
}
inline void Direct_RBC_Tag::_internal_set_rank(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rank_ = value;
}
inline void Direct_RBC_Tag::set_rank(uint32_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.RBC.Tag.rank)
}

// required uint32 seq = 3;
inline bool Direct_RBC_Tag::_internal_has_seq() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Direct_RBC_Tag::has_seq() const {
  return _internal_has_seq();
}
inline void Direct_RBC_Tag::clear_seq() {
  _impl_.seq_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Direct_RBC_Tag::_internal_seq() const {
  return _impl_.seq_;
}
inline uint32_t Direct_RBC_Tag::seq() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.Tag.seq)
  return _internal_seq();
}
inline void Direct_RBC_Tag::_internal_set_seq(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.seq_ = value;
}
inline void Direct_RBC_Tag::set_seq(uint32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.RBC.Tag.seq)
}

// -------------------------------------------------------------------

// Direct_RBC_Message

// required bytes message = 2;
inline bool Direct_RBC_Message::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Direct_RBC_Message::has_message() const {
  return _internal_has_message();
}
inline void Direct_RBC_Message::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Direct_RBC_Message::message() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.Message.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Direct_RBC_Message::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.RBC.Message.message)
}
inline std::string* Direct_RBC_Message::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.Message.message)
  return _s;
}
inline const std::string& Direct_RBC_Message::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Direct_RBC_Message::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Direct_RBC_Message::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Direct_RBC_Message::release_message() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.Message.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Direct_RBC_Message::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.Message.message)
}

// -------------------------------------------------------------------

// Direct_RBC_Hash

// required string msg_hash = 2;
inline bool Direct_RBC_Hash::_internal_has_msg_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Direct_RBC_Hash::has_msg_hash() const {
  return _internal_has_msg_hash();
}
inline void Direct_RBC_Hash::clear_msg_hash() {
  _impl_.msg_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Direct_RBC_Hash::msg_hash() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.Hash.msg_hash)
  return _internal_msg_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Direct_RBC_Hash::set_msg_hash(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.RBC.Hash.msg_hash)
}
inline std::string* Direct_RBC_Hash::mutable_msg_hash() {
  std::string* _s = _internal_mutable_msg_hash();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.Hash.msg_hash)
  return _s;
}
inline const std::string& Direct_RBC_Hash::_internal_msg_hash() const {
  return _impl_.msg_hash_.Get();
}
inline void Direct_RBC_Hash::_internal_set_msg_hash(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Direct_RBC_Hash::_internal_mutable_msg_hash() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Direct_RBC_Hash::release_msg_hash() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.Hash.msg_hash)
  if (!_internal_has_msg_hash()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_hash_.IsDefault()) {
    _impl_.msg_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Direct_RBC_Hash::set_allocated_msg_hash(std::string* msg_hash) {
  if (msg_hash != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_hash_.SetAllocated(msg_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_hash_.IsDefault()) {
    _impl_.msg_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.Hash.msg_hash)
}

// -------------------------------------------------------------------

// Direct_RBC

// required .fetch.consensus.pb.Direct.RBC.Tag tag = 1;
inline bool Direct_RBC::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tag_ != nullptr);
  return value;
}
inline bool Direct_RBC::has_tag() const {
  return _internal_has_tag();
}
inline void Direct_RBC::clear_tag() {
  if (_impl_.tag_ != nullptr) _impl_.tag_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::fetch::consensus::pb::Direct_RBC_Tag& Direct_RBC::_internal_tag() const {
  const ::fetch::consensus::pb::Direct_RBC_Tag* p = _impl_.tag_;
  return p != nullptr ? *p : reinterpret_cast<const ::fetch::consensus::pb::Direct_RBC_Tag&>(
      ::fetch::consensus::pb::_Direct_RBC_Tag_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC_Tag& Direct_RBC::tag() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.tag)
  return _internal_tag();
}
inline void Direct_RBC::unsafe_arena_set_allocated_tag(
    ::fetch::consensus::pb::Direct_RBC_Tag* tag) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tag_);
  }
  _impl_.tag_ = tag;
  if (tag) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.RBC.tag)
}
inline ::fetch::consensus::pb::Direct_RBC_Tag* Direct_RBC::release_tag() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fetch::consensus::pb::Direct_RBC_Tag* temp = _impl_.tag_;
  _impl_.tag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fetch::consensus::pb::Direct_RBC_Tag* Direct_RBC::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.tag)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::fetch::consensus::pb::Direct_RBC_Tag* temp = _impl_.tag_;
  _impl_.tag_ = nullptr;
  return temp;
}
inline ::fetch::consensus::pb::Direct_RBC_Tag* Direct_RBC::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tag_ == nullptr) {
    auto* p = CreateMaybeMessage<::fetch::consensus::pb::Direct_RBC_Tag>(GetArenaForAllocation());
    _impl_.tag_ = p;
  }
  return _impl_.tag_;
}
inline ::fetch::consensus::pb::Direct_RBC_Tag* Direct_RBC::mutable_tag() {
  ::fetch::consensus::pb::Direct_RBC_Tag* _msg = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.tag)
  return _msg;
}
inline void Direct_RBC::set_allocated_tag(::fetch::consensus::pb::Direct_RBC_Tag* tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tag_;
  }
  if (tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tag);
    if (message_arena != submessage_arena) {
      tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:fetch.consensus.pb.Direct.RBC.tag)
}

// .fetch.consensus.pb.Direct.RBC.Message broadcast = 2;
inline bool Direct_RBC::_internal_has_broadcast() const {
  return payload_case() == kBroadcast;
}
inline bool Direct_RBC::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void Direct_RBC::set_has_broadcast() {
  _impl_._oneof_case_[0] = kBroadcast;
}
inline void Direct_RBC::clear_broadcast() {
  if (_internal_has_broadcast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.broadcast_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::release_broadcast() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.broadcast)
  if (_internal_has_broadcast()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Message* temp = _impl_.payload_.broadcast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_RBC_Message& Direct_RBC::_internal_broadcast() const {
  return _internal_has_broadcast()
      ? *_impl_.payload_.broadcast_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_RBC_Message&>(::fetch::consensus::pb::_Direct_RBC_Message_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC_Message& Direct_RBC::broadcast() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.broadcast)
  return _internal_broadcast();
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.RBC.broadcast)
  if (_internal_has_broadcast()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Message* temp = _impl_.payload_.broadcast_;
    _impl_.payload_.broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct_RBC::unsafe_arena_set_allocated_broadcast(::fetch::consensus::pb::Direct_RBC_Message* broadcast) {
  clear_payload();
  if (broadcast) {
    set_has_broadcast();
    _impl_.payload_.broadcast_ = broadcast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.RBC.broadcast)
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::_internal_mutable_broadcast() {
  if (!_internal_has_broadcast()) {
    clear_payload();
    set_has_broadcast();
    _impl_.payload_.broadcast_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Message >(GetArenaForAllocation());
  }
  return _impl_.payload_.broadcast_;
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::mutable_broadcast() {
  ::fetch::consensus::pb::Direct_RBC_Message* _msg = _internal_mutable_broadcast();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.broadcast)
  return _msg;
}

// .fetch.consensus.pb.Direct.RBC.Hash echo = 3;
inline bool Direct_RBC::_internal_has_echo() const {
  return payload_case() == kEcho;
}
inline bool Direct_RBC::has_echo() const {
  return _internal_has_echo();
}
inline void Direct_RBC::set_has_echo() {
  _impl_._oneof_case_[0] = kEcho;
}
inline void Direct_RBC::clear_echo() {
  if (_internal_has_echo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.echo_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::release_echo() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.echo)
  if (_internal_has_echo()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Hash* temp = _impl_.payload_.echo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_RBC_Hash& Direct_RBC::_internal_echo() const {
  return _internal_has_echo()
      ? *_impl_.payload_.echo_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_RBC_Hash&>(::fetch::consensus::pb::_Direct_RBC_Hash_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC_Hash& Direct_RBC::echo() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.echo)
  return _internal_echo();
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::unsafe_arena_release_echo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.RBC.echo)
  if (_internal_has_echo()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Hash* temp = _impl_.payload_.echo_;
    _impl_.payload_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct_RBC::unsafe_arena_set_allocated_echo(::fetch::consensus::pb::Direct_RBC_Hash* echo) {
  clear_payload();
  if (echo) {
    set_has_echo();
    _impl_.payload_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.RBC.echo)
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::_internal_mutable_echo() {
  if (!_internal_has_echo()) {
    clear_payload();
    set_has_echo();
    _impl_.payload_.echo_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Hash >(GetArenaForAllocation());
  }
  return _impl_.payload_.echo_;
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::mutable_echo() {
  ::fetch::consensus::pb::Direct_RBC_Hash* _msg = _internal_mutable_echo();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.echo)
  return _msg;
}

// .fetch.consensus.pb.Direct.RBC.Hash ready = 4;
inline bool Direct_RBC::_internal_has_ready() const {
  return payload_case() == kReady;
}
inline bool Direct_RBC::has_ready() const {
  return _internal_has_ready();
}
inline void Direct_RBC::set_has_ready() {
  _impl_._oneof_case_[0] = kReady;
}
inline void Direct_RBC::clear_ready() {
  if (_internal_has_ready()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.ready_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::release_ready() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.ready)
  if (_internal_has_ready()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Hash* temp = _impl_.payload_.ready_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_RBC_Hash& Direct_RBC::_internal_ready() const {
  return _internal_has_ready()
      ? *_impl_.payload_.ready_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_RBC_Hash&>(::fetch::consensus::pb::_Direct_RBC_Hash_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC_Hash& Direct_RBC::ready() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.ready)
  return _internal_ready();
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::unsafe_arena_release_ready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.RBC.ready)
  if (_internal_has_ready()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Hash* temp = _impl_.payload_.ready_;
    _impl_.payload_.ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct_RBC::unsafe_arena_set_allocated_ready(::fetch::consensus::pb::Direct_RBC_Hash* ready) {
  clear_payload();
  if (ready) {
    set_has_ready();
    _impl_.payload_.ready_ = ready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.RBC.ready)
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::_internal_mutable_ready() {
  if (!_internal_has_ready()) {
    clear_payload();
    set_has_ready();
    _impl_.payload_.ready_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Hash >(GetArenaForAllocation());
  }
  return _impl_.payload_.ready_;
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::mutable_ready() {
  ::fetch::consensus::pb::Direct_RBC_Hash* _msg = _internal_mutable_ready();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.ready)
  return _msg;
}

// .fetch.consensus.pb.Direct.RBC.Hash request = 5;
inline bool Direct_RBC::_internal_has_request() const {
  return payload_case() == kRequest;
}
inline bool Direct_RBC::has_request() const {
  return _internal_has_request();
}
inline void Direct_RBC::set_has_request() {
  _impl_._oneof_case_[0] = kRequest;
}
inline void Direct_RBC::clear_request() {
  if (_internal_has_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.request_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::release_request() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.request)
  if (_internal_has_request()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Hash* temp = _impl_.payload_.request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_RBC_Hash& Direct_RBC::_internal_request() const {
  return _internal_has_request()
      ? *_impl_.payload_.request_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_RBC_Hash&>(::fetch::consensus::pb::_Direct_RBC_Hash_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC_Hash& Direct_RBC::request() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.request)
  return _internal_request();
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.RBC.request)
  if (_internal_has_request()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Hash* temp = _impl_.payload_.request_;
    _impl_.payload_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct_RBC::unsafe_arena_set_allocated_request(::fetch::consensus::pb::Direct_RBC_Hash* request) {
  clear_payload();
  if (request) {
    set_has_request();
    _impl_.payload_.request_ = request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.RBC.request)
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::_internal_mutable_request() {
  if (!_internal_has_request()) {
    clear_payload();
    set_has_request();
    _impl_.payload_.request_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Hash >(GetArenaForAllocation());
  }
  return _impl_.payload_.request_;
}
inline ::fetch::consensus::pb::Direct_RBC_Hash* Direct_RBC::mutable_request() {
  ::fetch::consensus::pb::Direct_RBC_Hash* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.request)
  return _msg;
}

// .fetch.consensus.pb.Direct.RBC.Message answer = 6;
inline bool Direct_RBC::_internal_has_answer() const {
  return payload_case() == kAnswer;
}
inline bool Direct_RBC::has_answer() const {
  return _internal_has_answer();
}
inline void Direct_RBC::set_has_answer() {
  _impl_._oneof_case_[0] = kAnswer;
}
inline void Direct_RBC::clear_answer() {
  if (_internal_has_answer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.answer_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::release_answer() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.RBC.answer)
  if (_internal_has_answer()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Message* temp = _impl_.payload_.answer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_RBC_Message& Direct_RBC::_internal_answer() const {
  return _internal_has_answer()
      ? *_impl_.payload_.answer_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_RBC_Message&>(::fetch::consensus::pb::_Direct_RBC_Message_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC_Message& Direct_RBC::answer() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.RBC.answer)
  return _internal_answer();
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.RBC.answer)
  if (_internal_has_answer()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC_Message* temp = _impl_.payload_.answer_;
    _impl_.payload_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct_RBC::unsafe_arena_set_allocated_answer(::fetch::consensus::pb::Direct_RBC_Message* answer) {
  clear_payload();
  if (answer) {
    set_has_answer();
    _impl_.payload_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.RBC.answer)
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_payload();
    set_has_answer();
    _impl_.payload_.answer_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC_Message >(GetArenaForAllocation());
  }
  return _impl_.payload_.answer_;
}
inline ::fetch::consensus::pb::Direct_RBC_Message* Direct_RBC::mutable_answer() {
  ::fetch::consensus::pb::Direct_RBC_Message* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.RBC.answer)
  return _msg;
}

inline bool Direct_RBC::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Direct_RBC::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Direct_RBC::PayloadCase Direct_RBC::payload_case() const {
  return Direct_RBC::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Direct_NoiseMessage

// repeated uint32 payload = 1;
inline int Direct_NoiseMessage::_internal_payload_size() const {
  return _impl_.payload_.size();
}
inline int Direct_NoiseMessage::payload_size() const {
  return _internal_payload_size();
}
inline void Direct_NoiseMessage::clear_payload() {
  _impl_.payload_.Clear();
}
inline uint32_t Direct_NoiseMessage::_internal_payload(int index) const {
  return _impl_.payload_.Get(index);
}
inline uint32_t Direct_NoiseMessage::payload(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.NoiseMessage.payload)
  return _internal_payload(index);
}
inline void Direct_NoiseMessage::set_payload(int index, uint32_t value) {
  _impl_.payload_.Set(index, value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.NoiseMessage.payload)
}
inline void Direct_NoiseMessage::_internal_add_payload(uint32_t value) {
  _impl_.payload_.Add(value);
}
inline void Direct_NoiseMessage::add_payload(uint32_t value) {
  _internal_add_payload(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Direct.NoiseMessage.payload)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Direct_NoiseMessage::_internal_payload() const {
  return _impl_.payload_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Direct_NoiseMessage::payload() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Direct.NoiseMessage.payload)
  return _internal_payload();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Direct_NoiseMessage::_internal_mutable_payload() {
  return &_impl_.payload_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Direct_NoiseMessage::mutable_payload() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Direct.NoiseMessage.payload)
  return _internal_mutable_payload();
}

// -------------------------------------------------------------------

// Direct

// required uint32 committee_id = 1;
inline bool Direct::_internal_has_committee_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Direct::has_committee_id() const {
  return _internal_has_committee_id();
}
inline void Direct::clear_committee_id() {
  _impl_.committee_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Direct::_internal_committee_id() const {
  return _impl_.committee_id_;
}
inline uint32_t Direct::committee_id() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.committee_id)
  return _internal_committee_id();
}
inline void Direct::_internal_set_committee_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.committee_id_ = value;
}
inline void Direct::set_committee_id(uint32_t value) {
  _internal_set_committee_id(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Direct.committee_id)
}

// .fetch.consensus.pb.Direct.RBC rbc_msg = 2;
inline bool Direct::_internal_has_rbc_msg() const {
  return payload_case() == kRbcMsg;
}
inline bool Direct::has_rbc_msg() const {
  return _internal_has_rbc_msg();
}
inline void Direct::set_has_rbc_msg() {
  _impl_._oneof_case_[0] = kRbcMsg;
}
inline void Direct::clear_rbc_msg() {
  if (_internal_has_rbc_msg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rbc_msg_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_RBC* Direct::release_rbc_msg() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.rbc_msg)
  if (_internal_has_rbc_msg()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC* temp = _impl_.payload_.rbc_msg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rbc_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_RBC& Direct::_internal_rbc_msg() const {
  return _internal_has_rbc_msg()
      ? *_impl_.payload_.rbc_msg_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_RBC&>(::fetch::consensus::pb::_Direct_RBC_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_RBC& Direct::rbc_msg() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.rbc_msg)
  return _internal_rbc_msg();
}
inline ::fetch::consensus::pb::Direct_RBC* Direct::unsafe_arena_release_rbc_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.rbc_msg)
  if (_internal_has_rbc_msg()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_RBC* temp = _impl_.payload_.rbc_msg_;
    _impl_.payload_.rbc_msg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct::unsafe_arena_set_allocated_rbc_msg(::fetch::consensus::pb::Direct_RBC* rbc_msg) {
  clear_payload();
  if (rbc_msg) {
    set_has_rbc_msg();
    _impl_.payload_.rbc_msg_ = rbc_msg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.rbc_msg)
}
inline ::fetch::consensus::pb::Direct_RBC* Direct::_internal_mutable_rbc_msg() {
  if (!_internal_has_rbc_msg()) {
    clear_payload();
    set_has_rbc_msg();
    _impl_.payload_.rbc_msg_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_RBC >(GetArenaForAllocation());
  }
  return _impl_.payload_.rbc_msg_;
}
inline ::fetch::consensus::pb::Direct_RBC* Direct::mutable_rbc_msg() {
  ::fetch::consensus::pb::Direct_RBC* _msg = _internal_mutable_rbc_msg();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.rbc_msg)
  return _msg;
}

// .fetch.consensus.pb.Direct.NoiseMessage handshake = 3;
inline bool Direct::_internal_has_handshake() const {
  return payload_case() == kHandshake;
}
inline bool Direct::has_handshake() const {
  return _internal_has_handshake();
}
inline void Direct::set_has_handshake() {
  _impl_._oneof_case_[0] = kHandshake;
}
inline void Direct::clear_handshake() {
  if (_internal_has_handshake()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.handshake_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::release_handshake() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.handshake)
  if (_internal_has_handshake()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_NoiseMessage* temp = _impl_.payload_.handshake_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_NoiseMessage& Direct::_internal_handshake() const {
  return _internal_has_handshake()
      ? *_impl_.payload_.handshake_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_NoiseMessage&>(::fetch::consensus::pb::_Direct_NoiseMessage_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_NoiseMessage& Direct::handshake() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.handshake)
  return _internal_handshake();
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::unsafe_arena_release_handshake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.handshake)
  if (_internal_has_handshake()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_NoiseMessage* temp = _impl_.payload_.handshake_;
    _impl_.payload_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct::unsafe_arena_set_allocated_handshake(::fetch::consensus::pb::Direct_NoiseMessage* handshake) {
  clear_payload();
  if (handshake) {
    set_has_handshake();
    _impl_.payload_.handshake_ = handshake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.handshake)
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::_internal_mutable_handshake() {
  if (!_internal_has_handshake()) {
    clear_payload();
    set_has_handshake();
    _impl_.payload_.handshake_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_NoiseMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.handshake_;
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::mutable_handshake() {
  ::fetch::consensus::pb::Direct_NoiseMessage* _msg = _internal_mutable_handshake();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.handshake)
  return _msg;
}

// .fetch.consensus.pb.Direct.NoiseMessage encrypted_cipher = 4;
inline bool Direct::_internal_has_encrypted_cipher() const {
  return payload_case() == kEncryptedCipher;
}
inline bool Direct::has_encrypted_cipher() const {
  return _internal_has_encrypted_cipher();
}
inline void Direct::set_has_encrypted_cipher() {
  _impl_._oneof_case_[0] = kEncryptedCipher;
}
inline void Direct::clear_encrypted_cipher() {
  if (_internal_has_encrypted_cipher()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.encrypted_cipher_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::release_encrypted_cipher() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Direct.encrypted_cipher)
  if (_internal_has_encrypted_cipher()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_NoiseMessage* temp = _impl_.payload_.encrypted_cipher_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.encrypted_cipher_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Direct_NoiseMessage& Direct::_internal_encrypted_cipher() const {
  return _internal_has_encrypted_cipher()
      ? *_impl_.payload_.encrypted_cipher_
      : reinterpret_cast< ::fetch::consensus::pb::Direct_NoiseMessage&>(::fetch::consensus::pb::_Direct_NoiseMessage_default_instance_);
}
inline const ::fetch::consensus::pb::Direct_NoiseMessage& Direct::encrypted_cipher() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Direct.encrypted_cipher)
  return _internal_encrypted_cipher();
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::unsafe_arena_release_encrypted_cipher() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Direct.encrypted_cipher)
  if (_internal_has_encrypted_cipher()) {
    clear_has_payload();
    ::fetch::consensus::pb::Direct_NoiseMessage* temp = _impl_.payload_.encrypted_cipher_;
    _impl_.payload_.encrypted_cipher_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Direct::unsafe_arena_set_allocated_encrypted_cipher(::fetch::consensus::pb::Direct_NoiseMessage* encrypted_cipher) {
  clear_payload();
  if (encrypted_cipher) {
    set_has_encrypted_cipher();
    _impl_.payload_.encrypted_cipher_ = encrypted_cipher;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Direct.encrypted_cipher)
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::_internal_mutable_encrypted_cipher() {
  if (!_internal_has_encrypted_cipher()) {
    clear_payload();
    set_has_encrypted_cipher();
    _impl_.payload_.encrypted_cipher_ = CreateMaybeMessage< ::fetch::consensus::pb::Direct_NoiseMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.encrypted_cipher_;
}
inline ::fetch::consensus::pb::Direct_NoiseMessage* Direct::mutable_encrypted_cipher() {
  ::fetch::consensus::pb::Direct_NoiseMessage* _msg = _internal_mutable_encrypted_cipher();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Direct.encrypted_cipher)
  return _msg;
}

inline bool Direct::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Direct::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Direct::PayloadCase Direct::payload_case() const {
  return Direct::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Broadcast_Committee

// repeated string nodes = 1;
inline int Broadcast_Committee::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int Broadcast_Committee::nodes_size() const {
  return _internal_nodes_size();
}
inline void Broadcast_Committee::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline std::string* Broadcast_Committee::add_nodes() {
  std::string* _s = _internal_add_nodes();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Broadcast.Committee.nodes)
  return _s;
}
inline const std::string& Broadcast_Committee::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const std::string& Broadcast_Committee::nodes(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Committee.nodes)
  return _internal_nodes(index);
}
inline std::string* Broadcast_Committee::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.Committee.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline void Broadcast_Committee::set_nodes(int index, const std::string& value) {
  _impl_.nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline void Broadcast_Committee::set_nodes(int index, std::string&& value) {
  _impl_.nodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline void Broadcast_Committee::set_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline void Broadcast_Committee::set_nodes(int index, const char* value, size_t size) {
  _impl_.nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline std::string* Broadcast_Committee::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline void Broadcast_Committee::add_nodes(const std::string& value) {
  _impl_.nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline void Broadcast_Committee::add_nodes(std::string&& value) {
  _impl_.nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline void Broadcast_Committee::add_nodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline void Broadcast_Committee::add_nodes(const char* value, size_t size) {
  _impl_.nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Broadcast.Committee.nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Broadcast_Committee::nodes() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Broadcast.Committee.nodes)
  return _impl_.nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Broadcast_Committee::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Broadcast.Committee.nodes)
  return &_impl_.nodes_;
}

// -------------------------------------------------------------------

// Broadcast_Complaints

// repeated string nodes = 1;
inline int Broadcast_Complaints::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int Broadcast_Complaints::nodes_size() const {
  return _internal_nodes_size();
}
inline void Broadcast_Complaints::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline std::string* Broadcast_Complaints::add_nodes() {
  std::string* _s = _internal_add_nodes();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Broadcast.Complaints.nodes)
  return _s;
}
inline const std::string& Broadcast_Complaints::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const std::string& Broadcast_Complaints::nodes(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Complaints.nodes)
  return _internal_nodes(index);
}
inline std::string* Broadcast_Complaints::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.Complaints.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline void Broadcast_Complaints::set_nodes(int index, const std::string& value) {
  _impl_.nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline void Broadcast_Complaints::set_nodes(int index, std::string&& value) {
  _impl_.nodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline void Broadcast_Complaints::set_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline void Broadcast_Complaints::set_nodes(int index, const char* value, size_t size) {
  _impl_.nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline std::string* Broadcast_Complaints::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline void Broadcast_Complaints::add_nodes(const std::string& value) {
  _impl_.nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline void Broadcast_Complaints::add_nodes(std::string&& value) {
  _impl_.nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline void Broadcast_Complaints::add_nodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline void Broadcast_Complaints::add_nodes(const char* value, size_t size) {
  _impl_.nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Broadcast.Complaints.nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Broadcast_Complaints::nodes() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Broadcast.Complaints.nodes)
  return _impl_.nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Broadcast_Complaints::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Broadcast.Complaints.nodes)
  return &_impl_.nodes_;
}

// -------------------------------------------------------------------

// Broadcast_Shares

// required uint64 phase = 1;
inline bool Broadcast_Shares::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Broadcast_Shares::has_phase() const {
  return _internal_has_phase();
}
inline void Broadcast_Shares::clear_phase() {
  _impl_.phase_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Broadcast_Shares::_internal_phase() const {
  return _impl_.phase_;
}
inline uint64_t Broadcast_Shares::phase() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Shares.phase)
  return _internal_phase();
}
inline void Broadcast_Shares::_internal_set_phase(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_ = value;
}
inline void Broadcast_Shares::set_phase(uint64_t value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.phase)
}

// repeated string first = 2;
inline int Broadcast_Shares::_internal_first_size() const {
  return _impl_.first_.size();
}
inline int Broadcast_Shares::first_size() const {
  return _internal_first_size();
}
inline void Broadcast_Shares::clear_first() {
  _impl_.first_.Clear();
}
inline std::string* Broadcast_Shares::add_first() {
  std::string* _s = _internal_add_first();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Broadcast.Shares.first)
  return _s;
}
inline const std::string& Broadcast_Shares::_internal_first(int index) const {
  return _impl_.first_.Get(index);
}
inline const std::string& Broadcast_Shares::first(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Shares.first)
  return _internal_first(index);
}
inline std::string* Broadcast_Shares::mutable_first(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.Shares.first)
  return _impl_.first_.Mutable(index);
}
inline void Broadcast_Shares::set_first(int index, const std::string& value) {
  _impl_.first_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.first)
}
inline void Broadcast_Shares::set_first(int index, std::string&& value) {
  _impl_.first_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.first)
}
inline void Broadcast_Shares::set_first(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.first_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Broadcast.Shares.first)
}
inline void Broadcast_Shares::set_first(int index, const char* value, size_t size) {
  _impl_.first_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Broadcast.Shares.first)
}
inline std::string* Broadcast_Shares::_internal_add_first() {
  return _impl_.first_.Add();
}
inline void Broadcast_Shares::add_first(const std::string& value) {
  _impl_.first_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Shares.first)
}
inline void Broadcast_Shares::add_first(std::string&& value) {
  _impl_.first_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Shares.first)
}
inline void Broadcast_Shares::add_first(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.first_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Broadcast.Shares.first)
}
inline void Broadcast_Shares::add_first(const char* value, size_t size) {
  _impl_.first_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Broadcast.Shares.first)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Broadcast_Shares::first() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Broadcast.Shares.first)
  return _impl_.first_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Broadcast_Shares::mutable_first() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Broadcast.Shares.first)
  return &_impl_.first_;
}

// repeated string second = 3;
inline int Broadcast_Shares::_internal_second_size() const {
  return _impl_.second_.size();
}
inline int Broadcast_Shares::second_size() const {
  return _internal_second_size();
}
inline void Broadcast_Shares::clear_second() {
  _impl_.second_.Clear();
}
inline std::string* Broadcast_Shares::add_second() {
  std::string* _s = _internal_add_second();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Broadcast.Shares.second)
  return _s;
}
inline const std::string& Broadcast_Shares::_internal_second(int index) const {
  return _impl_.second_.Get(index);
}
inline const std::string& Broadcast_Shares::second(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Shares.second)
  return _internal_second(index);
}
inline std::string* Broadcast_Shares::mutable_second(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.Shares.second)
  return _impl_.second_.Mutable(index);
}
inline void Broadcast_Shares::set_second(int index, const std::string& value) {
  _impl_.second_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.second)
}
inline void Broadcast_Shares::set_second(int index, std::string&& value) {
  _impl_.second_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.second)
}
inline void Broadcast_Shares::set_second(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.second_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Broadcast.Shares.second)
}
inline void Broadcast_Shares::set_second(int index, const char* value, size_t size) {
  _impl_.second_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Broadcast.Shares.second)
}
inline std::string* Broadcast_Shares::_internal_add_second() {
  return _impl_.second_.Add();
}
inline void Broadcast_Shares::add_second(const std::string& value) {
  _impl_.second_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Shares.second)
}
inline void Broadcast_Shares::add_second(std::string&& value) {
  _impl_.second_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Shares.second)
}
inline void Broadcast_Shares::add_second(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.second_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Broadcast.Shares.second)
}
inline void Broadcast_Shares::add_second(const char* value, size_t size) {
  _impl_.second_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Broadcast.Shares.second)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Broadcast_Shares::second() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Broadcast.Shares.second)
  return _impl_.second_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Broadcast_Shares::mutable_second() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Broadcast.Shares.second)
  return &_impl_.second_;
}

// repeated string reporter = 4;
inline int Broadcast_Shares::_internal_reporter_size() const {
  return _impl_.reporter_.size();
}
inline int Broadcast_Shares::reporter_size() const {
  return _internal_reporter_size();
}
inline void Broadcast_Shares::clear_reporter() {
  _impl_.reporter_.Clear();
}
inline std::string* Broadcast_Shares::add_reporter() {
  std::string* _s = _internal_add_reporter();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Broadcast.Shares.reporter)
  return _s;
}
inline const std::string& Broadcast_Shares::_internal_reporter(int index) const {
  return _impl_.reporter_.Get(index);
}
inline const std::string& Broadcast_Shares::reporter(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Shares.reporter)
  return _internal_reporter(index);
}
inline std::string* Broadcast_Shares::mutable_reporter(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.Shares.reporter)
  return _impl_.reporter_.Mutable(index);
}
inline void Broadcast_Shares::set_reporter(int index, const std::string& value) {
  _impl_.reporter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline void Broadcast_Shares::set_reporter(int index, std::string&& value) {
  _impl_.reporter_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline void Broadcast_Shares::set_reporter(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.reporter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline void Broadcast_Shares::set_reporter(int index, const char* value, size_t size) {
  _impl_.reporter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline std::string* Broadcast_Shares::_internal_add_reporter() {
  return _impl_.reporter_.Add();
}
inline void Broadcast_Shares::add_reporter(const std::string& value) {
  _impl_.reporter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline void Broadcast_Shares::add_reporter(std::string&& value) {
  _impl_.reporter_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline void Broadcast_Shares::add_reporter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.reporter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline void Broadcast_Shares::add_reporter(const char* value, size_t size) {
  _impl_.reporter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Broadcast.Shares.reporter)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Broadcast_Shares::reporter() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Broadcast.Shares.reporter)
  return _impl_.reporter_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Broadcast_Shares::mutable_reporter() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Broadcast.Shares.reporter)
  return &_impl_.reporter_;
}

// -------------------------------------------------------------------

// Broadcast_Coefficients

// required uint64 phase = 1;
inline bool Broadcast_Coefficients::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Broadcast_Coefficients::has_phase() const {
  return _internal_has_phase();
}
inline void Broadcast_Coefficients::clear_phase() {
  _impl_.phase_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Broadcast_Coefficients::_internal_phase() const {
  return _impl_.phase_;
}
inline uint64_t Broadcast_Coefficients::phase() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Coefficients.phase)
  return _internal_phase();
}
inline void Broadcast_Coefficients::_internal_set_phase(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_ = value;
}
inline void Broadcast_Coefficients::set_phase(uint64_t value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Coefficients.phase)
}

// repeated string coefficients = 2;
inline int Broadcast_Coefficients::_internal_coefficients_size() const {
  return _impl_.coefficients_.size();
}
inline int Broadcast_Coefficients::coefficients_size() const {
  return _internal_coefficients_size();
}
inline void Broadcast_Coefficients::clear_coefficients() {
  _impl_.coefficients_.Clear();
}
inline std::string* Broadcast_Coefficients::add_coefficients() {
  std::string* _s = _internal_add_coefficients();
  // @@protoc_insertion_point(field_add_mutable:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
  return _s;
}
inline const std::string& Broadcast_Coefficients::_internal_coefficients(int index) const {
  return _impl_.coefficients_.Get(index);
}
inline const std::string& Broadcast_Coefficients::coefficients(int index) const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
  return _internal_coefficients(index);
}
inline std::string* Broadcast_Coefficients::mutable_coefficients(int index) {
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
  return _impl_.coefficients_.Mutable(index);
}
inline void Broadcast_Coefficients::set_coefficients(int index, const std::string& value) {
  _impl_.coefficients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline void Broadcast_Coefficients::set_coefficients(int index, std::string&& value) {
  _impl_.coefficients_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline void Broadcast_Coefficients::set_coefficients(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.coefficients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline void Broadcast_Coefficients::set_coefficients(int index, const char* value, size_t size) {
  _impl_.coefficients_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline std::string* Broadcast_Coefficients::_internal_add_coefficients() {
  return _impl_.coefficients_.Add();
}
inline void Broadcast_Coefficients::add_coefficients(const std::string& value) {
  _impl_.coefficients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline void Broadcast_Coefficients::add_coefficients(std::string&& value) {
  _impl_.coefficients_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline void Broadcast_Coefficients::add_coefficients(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.coefficients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline void Broadcast_Coefficients::add_coefficients(const char* value, size_t size) {
  _impl_.coefficients_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Broadcast_Coefficients::coefficients() const {
  // @@protoc_insertion_point(field_list:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
  return _impl_.coefficients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Broadcast_Coefficients::mutable_coefficients() {
  // @@protoc_insertion_point(field_mutable_list:fetch.consensus.pb.Broadcast.Coefficients.coefficients)
  return &_impl_.coefficients_;
}

// -------------------------------------------------------------------

// Broadcast

// .fetch.consensus.pb.Broadcast.Complaints complaints = 1;
inline bool Broadcast::_internal_has_complaints() const {
  return payload_case() == kComplaints;
}
inline bool Broadcast::has_complaints() const {
  return _internal_has_complaints();
}
inline void Broadcast::set_has_complaints() {
  _impl_._oneof_case_[0] = kComplaints;
}
inline void Broadcast::clear_complaints() {
  if (_internal_has_complaints()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.complaints_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Broadcast_Complaints* Broadcast::release_complaints() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Broadcast.complaints)
  if (_internal_has_complaints()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Complaints* temp = _impl_.payload_.complaints_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.complaints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Broadcast_Complaints& Broadcast::_internal_complaints() const {
  return _internal_has_complaints()
      ? *_impl_.payload_.complaints_
      : reinterpret_cast< ::fetch::consensus::pb::Broadcast_Complaints&>(::fetch::consensus::pb::_Broadcast_Complaints_default_instance_);
}
inline const ::fetch::consensus::pb::Broadcast_Complaints& Broadcast::complaints() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.complaints)
  return _internal_complaints();
}
inline ::fetch::consensus::pb::Broadcast_Complaints* Broadcast::unsafe_arena_release_complaints() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Broadcast.complaints)
  if (_internal_has_complaints()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Complaints* temp = _impl_.payload_.complaints_;
    _impl_.payload_.complaints_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Broadcast::unsafe_arena_set_allocated_complaints(::fetch::consensus::pb::Broadcast_Complaints* complaints) {
  clear_payload();
  if (complaints) {
    set_has_complaints();
    _impl_.payload_.complaints_ = complaints;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Broadcast.complaints)
}
inline ::fetch::consensus::pb::Broadcast_Complaints* Broadcast::_internal_mutable_complaints() {
  if (!_internal_has_complaints()) {
    clear_payload();
    set_has_complaints();
    _impl_.payload_.complaints_ = CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Complaints >(GetArenaForAllocation());
  }
  return _impl_.payload_.complaints_;
}
inline ::fetch::consensus::pb::Broadcast_Complaints* Broadcast::mutable_complaints() {
  ::fetch::consensus::pb::Broadcast_Complaints* _msg = _internal_mutable_complaints();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.complaints)
  return _msg;
}

// .fetch.consensus.pb.Broadcast.Shares shares = 2;
inline bool Broadcast::_internal_has_shares() const {
  return payload_case() == kShares;
}
inline bool Broadcast::has_shares() const {
  return _internal_has_shares();
}
inline void Broadcast::set_has_shares() {
  _impl_._oneof_case_[0] = kShares;
}
inline void Broadcast::clear_shares() {
  if (_internal_has_shares()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.shares_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Broadcast_Shares* Broadcast::release_shares() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Broadcast.shares)
  if (_internal_has_shares()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Shares* temp = _impl_.payload_.shares_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.shares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Broadcast_Shares& Broadcast::_internal_shares() const {
  return _internal_has_shares()
      ? *_impl_.payload_.shares_
      : reinterpret_cast< ::fetch::consensus::pb::Broadcast_Shares&>(::fetch::consensus::pb::_Broadcast_Shares_default_instance_);
}
inline const ::fetch::consensus::pb::Broadcast_Shares& Broadcast::shares() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.shares)
  return _internal_shares();
}
inline ::fetch::consensus::pb::Broadcast_Shares* Broadcast::unsafe_arena_release_shares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Broadcast.shares)
  if (_internal_has_shares()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Shares* temp = _impl_.payload_.shares_;
    _impl_.payload_.shares_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Broadcast::unsafe_arena_set_allocated_shares(::fetch::consensus::pb::Broadcast_Shares* shares) {
  clear_payload();
  if (shares) {
    set_has_shares();
    _impl_.payload_.shares_ = shares;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Broadcast.shares)
}
inline ::fetch::consensus::pb::Broadcast_Shares* Broadcast::_internal_mutable_shares() {
  if (!_internal_has_shares()) {
    clear_payload();
    set_has_shares();
    _impl_.payload_.shares_ = CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Shares >(GetArenaForAllocation());
  }
  return _impl_.payload_.shares_;
}
inline ::fetch::consensus::pb::Broadcast_Shares* Broadcast::mutable_shares() {
  ::fetch::consensus::pb::Broadcast_Shares* _msg = _internal_mutable_shares();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.shares)
  return _msg;
}

// .fetch.consensus.pb.Broadcast.Coefficients coefficients = 3;
inline bool Broadcast::_internal_has_coefficients() const {
  return payload_case() == kCoefficients;
}
inline bool Broadcast::has_coefficients() const {
  return _internal_has_coefficients();
}
inline void Broadcast::set_has_coefficients() {
  _impl_._oneof_case_[0] = kCoefficients;
}
inline void Broadcast::clear_coefficients() {
  if (_internal_has_coefficients()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.coefficients_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Broadcast_Coefficients* Broadcast::release_coefficients() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Broadcast.coefficients)
  if (_internal_has_coefficients()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Coefficients* temp = _impl_.payload_.coefficients_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.coefficients_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Broadcast_Coefficients& Broadcast::_internal_coefficients() const {
  return _internal_has_coefficients()
      ? *_impl_.payload_.coefficients_
      : reinterpret_cast< ::fetch::consensus::pb::Broadcast_Coefficients&>(::fetch::consensus::pb::_Broadcast_Coefficients_default_instance_);
}
inline const ::fetch::consensus::pb::Broadcast_Coefficients& Broadcast::coefficients() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.coefficients)
  return _internal_coefficients();
}
inline ::fetch::consensus::pb::Broadcast_Coefficients* Broadcast::unsafe_arena_release_coefficients() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Broadcast.coefficients)
  if (_internal_has_coefficients()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Coefficients* temp = _impl_.payload_.coefficients_;
    _impl_.payload_.coefficients_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Broadcast::unsafe_arena_set_allocated_coefficients(::fetch::consensus::pb::Broadcast_Coefficients* coefficients) {
  clear_payload();
  if (coefficients) {
    set_has_coefficients();
    _impl_.payload_.coefficients_ = coefficients;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Broadcast.coefficients)
}
inline ::fetch::consensus::pb::Broadcast_Coefficients* Broadcast::_internal_mutable_coefficients() {
  if (!_internal_has_coefficients()) {
    clear_payload();
    set_has_coefficients();
    _impl_.payload_.coefficients_ = CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Coefficients >(GetArenaForAllocation());
  }
  return _impl_.payload_.coefficients_;
}
inline ::fetch::consensus::pb::Broadcast_Coefficients* Broadcast::mutable_coefficients() {
  ::fetch::consensus::pb::Broadcast_Coefficients* _msg = _internal_mutable_coefficients();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.coefficients)
  return _msg;
}

// .fetch.consensus.pb.Broadcast.Committee committee = 4;
inline bool Broadcast::_internal_has_committee() const {
  return payload_case() == kCommittee;
}
inline bool Broadcast::has_committee() const {
  return _internal_has_committee();
}
inline void Broadcast::set_has_committee() {
  _impl_._oneof_case_[0] = kCommittee;
}
inline void Broadcast::clear_committee() {
  if (_internal_has_committee()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.committee_;
    }
    clear_has_payload();
  }
}
inline ::fetch::consensus::pb::Broadcast_Committee* Broadcast::release_committee() {
  // @@protoc_insertion_point(field_release:fetch.consensus.pb.Broadcast.committee)
  if (_internal_has_committee()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Committee* temp = _impl_.payload_.committee_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.committee_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::fetch::consensus::pb::Broadcast_Committee& Broadcast::_internal_committee() const {
  return _internal_has_committee()
      ? *_impl_.payload_.committee_
      : reinterpret_cast< ::fetch::consensus::pb::Broadcast_Committee&>(::fetch::consensus::pb::_Broadcast_Committee_default_instance_);
}
inline const ::fetch::consensus::pb::Broadcast_Committee& Broadcast::committee() const {
  // @@protoc_insertion_point(field_get:fetch.consensus.pb.Broadcast.committee)
  return _internal_committee();
}
inline ::fetch::consensus::pb::Broadcast_Committee* Broadcast::unsafe_arena_release_committee() {
  // @@protoc_insertion_point(field_unsafe_arena_release:fetch.consensus.pb.Broadcast.committee)
  if (_internal_has_committee()) {
    clear_has_payload();
    ::fetch::consensus::pb::Broadcast_Committee* temp = _impl_.payload_.committee_;
    _impl_.payload_.committee_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Broadcast::unsafe_arena_set_allocated_committee(::fetch::consensus::pb::Broadcast_Committee* committee) {
  clear_payload();
  if (committee) {
    set_has_committee();
    _impl_.payload_.committee_ = committee;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fetch.consensus.pb.Broadcast.committee)
}
inline ::fetch::consensus::pb::Broadcast_Committee* Broadcast::_internal_mutable_committee() {
  if (!_internal_has_committee()) {
    clear_payload();
    set_has_committee();
    _impl_.payload_.committee_ = CreateMaybeMessage< ::fetch::consensus::pb::Broadcast_Committee >(GetArenaForAllocation());
  }
  return _impl_.payload_.committee_;
}
inline ::fetch::consensus::pb::Broadcast_Committee* Broadcast::mutable_committee() {
  ::fetch::consensus::pb::Broadcast_Committee* _msg = _internal_mutable_committee();
  // @@protoc_insertion_point(field_mutable:fetch.consensus.pb.Broadcast.committee)
  return _msg;
}

inline bool Broadcast::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Broadcast::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Broadcast::PayloadCase Broadcast::payload_case() const {
  return Broadcast::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace consensus
}  // namespace fetch

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_consensus_2eproto
